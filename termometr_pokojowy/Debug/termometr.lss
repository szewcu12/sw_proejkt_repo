
termometr.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001820  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000036  00800060  00001820  000018b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064b  00800096  00800096  000018ea  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000018ea  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000191c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000300  00000000  00000000  00001958  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003a38  00000000  00000000  00001c58  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001330  00000000  00000000  00005690  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001ecb  00000000  00000000  000069c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000920  00000000  00000000  0000888c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000111f  00000000  00000000  000091ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002d51  00000000  00000000  0000a2cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000288  00000000  00000000  0000d01c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	2e c0       	rjmp	.+92     	; 0x5e <__ctors_end>
       2:	00 00       	nop
       4:	48 c0       	rjmp	.+144    	; 0x96 <__bad_interrupt>
       6:	00 00       	nop
       8:	46 c0       	rjmp	.+140    	; 0x96 <__bad_interrupt>
       a:	00 00       	nop
       c:	44 c0       	rjmp	.+136    	; 0x96 <__bad_interrupt>
       e:	00 00       	nop
      10:	42 c0       	rjmp	.+132    	; 0x96 <__bad_interrupt>
      12:	00 00       	nop
      14:	40 c0       	rjmp	.+128    	; 0x96 <__bad_interrupt>
      16:	00 00       	nop
      18:	3e c0       	rjmp	.+124    	; 0x96 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	2e c6       	rjmp	.+3164   	; 0xc7a <__vector_7>
      1e:	00 00       	nop
      20:	3a c0       	rjmp	.+116    	; 0x96 <__bad_interrupt>
      22:	00 00       	nop
      24:	38 c0       	rjmp	.+112    	; 0x96 <__bad_interrupt>
      26:	00 00       	nop
      28:	d4 c1       	rjmp	.+936    	; 0x3d2 <__vector_10>
      2a:	00 00       	nop
      2c:	34 c0       	rjmp	.+104    	; 0x96 <__bad_interrupt>
      2e:	00 00       	nop
      30:	32 c0       	rjmp	.+100    	; 0x96 <__bad_interrupt>
      32:	00 00       	nop
      34:	30 c0       	rjmp	.+96     	; 0x96 <__bad_interrupt>
      36:	00 00       	nop
      38:	2e c0       	rjmp	.+92     	; 0x96 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	2c c0       	rjmp	.+88     	; 0x96 <__bad_interrupt>
      3e:	00 00       	nop
      40:	2a c0       	rjmp	.+84     	; 0x96 <__bad_interrupt>
      42:	00 00       	nop
      44:	28 c0       	rjmp	.+80     	; 0x96 <__bad_interrupt>
      46:	00 00       	nop
      48:	26 c0       	rjmp	.+76     	; 0x96 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	24 c0       	rjmp	.+72     	; 0x96 <__bad_interrupt>
      4e:	00 00       	nop
      50:	22 c0       	rjmp	.+68     	; 0x96 <__bad_interrupt>
	...

00000054 <__trampolines_end>:
      54:	3f 06       	cpc	r3, r31
      56:	5b 4f       	sbci	r21, 0xFB	; 251
      58:	66 6d       	ori	r22, 0xD6	; 214
      5a:	7d 07       	cpc	r23, r29
      5c:	7f 6f       	ori	r23, 0xFF	; 255

0000005e <__ctors_end>:
      5e:	11 24       	eor	r1, r1
      60:	1f be       	out	0x3f, r1	; 63
      62:	cf e5       	ldi	r28, 0x5F	; 95
      64:	d8 e0       	ldi	r29, 0x08	; 8
      66:	de bf       	out	0x3e, r29	; 62
      68:	cd bf       	out	0x3d, r28	; 61

0000006a <__do_copy_data>:
      6a:	10 e0       	ldi	r17, 0x00	; 0
      6c:	a0 e6       	ldi	r26, 0x60	; 96
      6e:	b0 e0       	ldi	r27, 0x00	; 0
      70:	e0 e2       	ldi	r30, 0x20	; 32
      72:	f8 e1       	ldi	r31, 0x18	; 24
      74:	02 c0       	rjmp	.+4      	; 0x7a <__do_copy_data+0x10>
      76:	05 90       	lpm	r0, Z+
      78:	0d 92       	st	X+, r0
      7a:	a6 39       	cpi	r26, 0x96	; 150
      7c:	b1 07       	cpc	r27, r17
      7e:	d9 f7       	brne	.-10     	; 0x76 <__do_copy_data+0xc>

00000080 <__do_clear_bss>:
      80:	26 e0       	ldi	r18, 0x06	; 6
      82:	a6 e9       	ldi	r26, 0x96	; 150
      84:	b0 e0       	ldi	r27, 0x00	; 0
      86:	01 c0       	rjmp	.+2      	; 0x8a <.do_clear_bss_start>

00000088 <.do_clear_bss_loop>:
      88:	1d 92       	st	X+, r1

0000008a <.do_clear_bss_start>:
      8a:	a1 3e       	cpi	r26, 0xE1	; 225
      8c:	b2 07       	cpc	r27, r18
      8e:	e1 f7       	brne	.-8      	; 0x88 <.do_clear_bss_loop>
      90:	0e d2       	rcall	.+1052   	; 0x4ae <main>
      92:	0c 94 0e 0c 	jmp	0x181c	; 0x181c <_exit>

00000096 <__bad_interrupt>:
      96:	b4 cf       	rjmp	.-152    	; 0x0 <__vectors>

00000098 <prvDisplayTemp>:

static xSemaphoreHandle Tim2s;

static void prvDisplayTemp(int16_t val);
static void prvDisplayTemp(int16_t val)
{
      98:	9c 01       	movw	r18, r24
	int16_t val_temp;
	if( val<0 ){
      9a:	97 ff       	sbrs	r25, 7
      9c:	07 c0       	rjmp	.+14     	; 0xac <prvDisplayTemp+0x14>
		LED_buf[3] = 0x80;
      9e:	80 e8       	ldi	r24, 0x80	; 128
      a0:	80 93 d8 06 	sts	0x06D8, r24	; 0x8006d8 <LED_buf+0x3>
		val_temp = val * (-1);
      a4:	31 95       	neg	r19
      a6:	21 95       	neg	r18
      a8:	31 09       	sbc	r19, r1
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <prvDisplayTemp+0x18>
	}
	else { 
		LED_buf[3] = 0; 
      ac:	10 92 d8 06 	sts	0x06D8, r1	; 0x8006d8 <LED_buf+0x3>
		val_temp = val;
		}
	if( val_temp<100 ){ LED_buf[2] = 0; }
      b0:	24 36       	cpi	r18, 0x64	; 100
      b2:	31 05       	cpc	r19, r1
      b4:	1c f4       	brge	.+6      	; 0xbc <prvDisplayTemp+0x24>
      b6:	10 92 d7 06 	sts	0x06D7, r1	; 0x8006d7 <LED_buf+0x2>
      ba:	0b c0       	rjmp	.+22     	; 0xd2 <prvDisplayTemp+0x3a>
		else{ LED_buf[2] = pgm_read_byte(&seg7[val_temp/100]); }
      bc:	c9 01       	movw	r24, r18
      be:	64 e6       	ldi	r22, 0x64	; 100
      c0:	70 e0       	ldi	r23, 0x00	; 0
      c2:	0e 94 c8 0b 	call	0x1790	; 0x1790 <__divmodhi4>
      c6:	fb 01       	movw	r30, r22
      c8:	ec 5a       	subi	r30, 0xAC	; 172
      ca:	ff 4f       	sbci	r31, 0xFF	; 255
      cc:	e4 91       	lpm	r30, Z
      ce:	e0 93 d7 06 	sts	0x06D7, r30	; 0x8006d7 <LED_buf+0x2>
	LED_buf[1] = 0x80 | pgm_read_byte(&seg7[(val_temp/10)%10]);
      d2:	ea e0       	ldi	r30, 0x0A	; 10
      d4:	f0 e0       	ldi	r31, 0x00	; 0
      d6:	c9 01       	movw	r24, r18
      d8:	bf 01       	movw	r22, r30
      da:	0e 94 c8 0b 	call	0x1790	; 0x1790 <__divmodhi4>
      de:	9c 01       	movw	r18, r24
      e0:	cb 01       	movw	r24, r22
      e2:	bf 01       	movw	r22, r30
      e4:	0e 94 c8 0b 	call	0x1790	; 0x1790 <__divmodhi4>
      e8:	fc 01       	movw	r30, r24
      ea:	ec 5a       	subi	r30, 0xAC	; 172
      ec:	ff 4f       	sbci	r31, 0xFF	; 255
      ee:	84 91       	lpm	r24, Z
      f0:	80 68       	ori	r24, 0x80	; 128
      f2:	80 93 d6 06 	sts	0x06D6, r24	; 0x8006d6 <LED_buf+0x1>
	LED_buf[0] = pgm_read_byte(&seg7[val_temp%10]);
      f6:	f9 01       	movw	r30, r18
      f8:	ec 5a       	subi	r30, 0xAC	; 172
      fa:	ff 4f       	sbci	r31, 0xFF	; 255
      fc:	e4 91       	lpm	r30, Z
      fe:	e0 93 d5 06 	sts	0x06D5, r30	; 0x8006d5 <LED_buf>
     102:	08 95       	ret

00000104 <vTaskKeysLed>:
							else{ mode = MODE_TEMP_ALARM_MIN; }
						break;
					
								
					}
					press=1;
     104:	c1 e0       	ldi	r28, 0x01	; 1
						case KEY2:	//zerowanie zarejestrowanych temperatur
							temp_min=temp_act; temp_max=temp_act;
						break;
						case KEY3:	//wejœcie do trybu ustawiania progu dolnego, kolejne wciœniêcie - ustawianie progu górnego
							if( mode == MODE_TEMP_ALARM_MIN ){ mode = MODE_TEMP_ALARM_MAX; }
							else{ mode = MODE_TEMP_ALARM_MIN; }
     106:	13 e0       	ldi	r17, 0x03	; 3
						break;
						case KEY2:	//zerowanie zarejestrowanych temperatur
							temp_min=temp_act; temp_max=temp_act;
						break;
						case KEY3:	//wejœcie do trybu ustawiania progu dolnego, kolejne wciœniêcie - ustawianie progu górnego
							if( mode == MODE_TEMP_ALARM_MIN ){ mode = MODE_TEMP_ALARM_MAX; }
     108:	04 e0       	ldi	r16, 0x04	; 4
				if (press==0)
				{
					switch ((~KBD1)&0x1F)
					{
						case KEY1:	//zmiana wyœwietlanej temperatury
							if( mode==MODE_TEMP_ACT ){ mode = MODE_TEMP_MIN; time_switch_mode=60; }
     10a:	dc e3       	ldi	r29, 0x3C	; 60
		if(KBD1==0x1F){ press=0; step=0; }
		KBD2=KBD1;
		
		if( time_switch_mode ){ time_switch_mode--; }
		else{
			if( mode == MODE_TEMP_MIN ){ mode=MODE_TEMP_MAX; time_switch_mode = 60; }
     10c:	82 e0       	ldi	r24, 0x02	; 2
     10e:	f8 2e       	mov	r15, r24
static void vTaskKeysLed(void *pvParameters)
{
	static uint8_t KBD1,KBD2,press,time_switch_mode,step;
	for( ;; )
	{
			KBD1=PIND & 0x1F;
     110:	80 b3       	in	r24, 0x10	; 16
     112:	8f 71       	andi	r24, 0x1F	; 31
		if( (KBD1 !=0x1F) && (KBD1 == KBD2) ){
     114:	8f 31       	cpi	r24, 0x1F	; 31
     116:	09 f4       	brne	.+2      	; 0x11a <vTaskKeysLed+0x16>
     118:	ed c0       	rjmp	.+474    	; 0x2f4 <vTaskKeysLed+0x1f0>
     11a:	90 91 99 00 	lds	r25, 0x0099	; 0x800099 <KBD2.1760>
     11e:	89 13       	cpse	r24, r25
     120:	7e c0       	rjmp	.+252    	; 0x21e <vTaskKeysLed+0x11a>
				if (press==0)
     122:	90 91 98 00 	lds	r25, 0x0098	; 0x800098 <press.1761>
     126:	91 11       	cpse	r25, r1
     128:	33 c0       	rjmp	.+102    	; 0x190 <vTaskKeysLed+0x8c>
				{
					switch ((~KBD1)&0x1F)
     12a:	28 2f       	mov	r18, r24
     12c:	30 e0       	ldi	r19, 0x00	; 0
     12e:	20 95       	com	r18
     130:	30 95       	com	r19
     132:	2f 71       	andi	r18, 0x1F	; 31
     134:	33 27       	eor	r19, r19
     136:	22 30       	cpi	r18, 0x02	; 2
     138:	31 05       	cpc	r19, r1
     13a:	a1 f0       	breq	.+40     	; 0x164 <vTaskKeysLed+0x60>
     13c:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <mode>
     140:	24 30       	cpi	r18, 0x04	; 4
     142:	31 05       	cpc	r19, r1
     144:	e1 f0       	breq	.+56     	; 0x17e <vTaskKeysLed+0x7a>
     146:	21 30       	cpi	r18, 0x01	; 1
     148:	31 05       	cpc	r19, r1
     14a:	01 f5       	brne	.+64     	; 0x18c <vTaskKeysLed+0x88>
					{
						case KEY1:	//zmiana wyœwietlanej temperatury
							if( mode==MODE_TEMP_ACT ){ mode = MODE_TEMP_MIN; time_switch_mode=60; }
     14c:	91 11       	cpse	r25, r1
     14e:	05 c0       	rjmp	.+10     	; 0x15a <vTaskKeysLed+0x56>
     150:	c0 93 9e 00 	sts	0x009E, r28	; 0x80009e <mode>
     154:	d0 93 97 00 	sts	0x0097, r29	; 0x800097 <time_switch_mode.1762>
     158:	19 c0       	rjmp	.+50     	; 0x18c <vTaskKeysLed+0x88>
							else{ mode=MODE_TEMP_ACT; time_switch_mode=0; }
     15a:	10 92 9e 00 	sts	0x009E, r1	; 0x80009e <mode>
     15e:	10 92 97 00 	sts	0x0097, r1	; 0x800097 <time_switch_mode.1762>
     162:	14 c0       	rjmp	.+40     	; 0x18c <vTaskKeysLed+0x88>
						break;
						case KEY2:	//zerowanie zarejestrowanych temperatur
							temp_min=temp_act; temp_max=temp_act;
     164:	20 91 d1 06 	lds	r18, 0x06D1	; 0x8006d1 <temp_act>
     168:	30 91 d2 06 	lds	r19, 0x06D2	; 0x8006d2 <temp_act+0x1>
     16c:	30 93 d0 06 	sts	0x06D0, r19	; 0x8006d0 <temp_min+0x1>
     170:	20 93 cf 06 	sts	0x06CF, r18	; 0x8006cf <temp_min>
     174:	30 93 ce 06 	sts	0x06CE, r19	; 0x8006ce <temp_max+0x1>
     178:	20 93 cd 06 	sts	0x06CD, r18	; 0x8006cd <temp_max>
						break;
     17c:	07 c0       	rjmp	.+14     	; 0x18c <vTaskKeysLed+0x88>
						case KEY3:	//wejœcie do trybu ustawiania progu dolnego, kolejne wciœniêcie - ustawianie progu górnego
							if( mode == MODE_TEMP_ALARM_MIN ){ mode = MODE_TEMP_ALARM_MAX; }
     17e:	93 30       	cpi	r25, 0x03	; 3
     180:	19 f4       	brne	.+6      	; 0x188 <vTaskKeysLed+0x84>
     182:	00 93 9e 00 	sts	0x009E, r16	; 0x80009e <mode>
     186:	02 c0       	rjmp	.+4      	; 0x18c <vTaskKeysLed+0x88>
							else{ mode = MODE_TEMP_ALARM_MIN; }
     188:	10 93 9e 00 	sts	0x009E, r17	; 0x80009e <mode>
						break;
					
								
					}
					press=1;
     18c:	c0 93 98 00 	sts	0x0098, r28	; 0x800098 <press.1761>
				}	
					if( (step==0) || (step>20) ){
     190:	90 91 96 00 	lds	r25, 0x0096	; 0x800096 <__data_end>
     194:	2f ef       	ldi	r18, 0xFF	; 255
     196:	29 0f       	add	r18, r25
     198:	24 31       	cpi	r18, 0x14	; 20
     19a:	20 f4       	brcc	.+8      	; 0x1a4 <vTaskKeysLed+0xa0>
								if( mode == MODE_TEMP_ALARM_MIN ){ temp_alarm_min++; }
								if( mode == MODE_TEMP_ALARM_MAX ){ temp_alarm_max++; }
							break;						
						}						
					}
					if(step<21){ step++; }
     19c:	9f 5f       	subi	r25, 0xFF	; 255
     19e:	90 93 96 00 	sts	0x0096, r25	; 0x800096 <__data_end>
     1a2:	3d c0       	rjmp	.+122    	; 0x21e <vTaskKeysLed+0x11a>
								
					}
					press=1;
				}	
					if( (step==0) || (step>20) ){
						switch ((~KBD1)&0x1F)
     1a4:	28 2f       	mov	r18, r24
     1a6:	30 e0       	ldi	r19, 0x00	; 0
     1a8:	20 95       	com	r18
     1aa:	30 95       	com	r19
     1ac:	2f 71       	andi	r18, 0x1F	; 31
     1ae:	33 27       	eor	r19, r19
     1b0:	40 91 9e 00 	lds	r20, 0x009E	; 0x80009e <mode>
     1b4:	28 30       	cpi	r18, 0x08	; 8
     1b6:	31 05       	cpc	r19, r1
     1b8:	21 f0       	breq	.+8      	; 0x1c2 <vTaskKeysLed+0xbe>
     1ba:	20 31       	cpi	r18, 0x10	; 16
     1bc:	31 05       	cpc	r19, r1
     1be:	99 f0       	breq	.+38     	; 0x1e6 <vTaskKeysLed+0xe2>
     1c0:	2b c0       	rjmp	.+86     	; 0x218 <vTaskKeysLed+0x114>
						{			
							case KEY4:	//zmniejszenie wartoœci progowej
								if( mode == MODE_TEMP_ALARM_MIN ){ temp_alarm_min--; }
     1c2:	43 30       	cpi	r20, 0x03	; 3
     1c4:	39 f4       	brne	.+14     	; 0x1d4 <vTaskKeysLed+0xd0>
     1c6:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <temp_alarm_min>
     1ca:	30 91 63 00 	lds	r19, 0x0063	; 0x800063 <temp_alarm_min+0x1>
     1ce:	21 50       	subi	r18, 0x01	; 1
     1d0:	31 09       	sbc	r19, r1
     1d2:	11 c0       	rjmp	.+34     	; 0x1f6 <vTaskKeysLed+0xf2>
								if( mode == MODE_TEMP_ALARM_MAX ){ temp_alarm_max--; }
     1d4:	44 30       	cpi	r20, 0x04	; 4
     1d6:	01 f5       	brne	.+64     	; 0x218 <vTaskKeysLed+0x114>
     1d8:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     1dc:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     1e0:	21 50       	subi	r18, 0x01	; 1
     1e2:	31 09       	sbc	r19, r1
     1e4:	15 c0       	rjmp	.+42     	; 0x210 <vTaskKeysLed+0x10c>
							break;
							case KEY5:	//zwiêkszenie wartoœci progowej
								if( mode == MODE_TEMP_ALARM_MIN ){ temp_alarm_min++; }
     1e6:	43 30       	cpi	r20, 0x03	; 3
     1e8:	59 f4       	brne	.+22     	; 0x200 <vTaskKeysLed+0xfc>
     1ea:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <temp_alarm_min>
     1ee:	30 91 63 00 	lds	r19, 0x0063	; 0x800063 <temp_alarm_min+0x1>
     1f2:	2f 5f       	subi	r18, 0xFF	; 255
     1f4:	3f 4f       	sbci	r19, 0xFF	; 255
     1f6:	30 93 63 00 	sts	0x0063, r19	; 0x800063 <temp_alarm_min+0x1>
     1fa:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <temp_alarm_min>
     1fe:	0c c0       	rjmp	.+24     	; 0x218 <vTaskKeysLed+0x114>
								if( mode == MODE_TEMP_ALARM_MAX ){ temp_alarm_max++; }
     200:	44 30       	cpi	r20, 0x04	; 4
     202:	51 f4       	brne	.+20     	; 0x218 <vTaskKeysLed+0x114>
     204:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     208:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     20c:	2f 5f       	subi	r18, 0xFF	; 255
     20e:	3f 4f       	sbci	r19, 0xFF	; 255
     210:	30 93 61 00 	sts	0x0061, r19	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     214:	20 93 60 00 	sts	0x0060, r18	; 0x800060 <__DATA_REGION_ORIGIN__>
							break;						
						}						
					}
					if(step<21){ step++; }
     218:	95 31       	cpi	r25, 0x15	; 21
     21a:	08 f4       	brcc	.+2      	; 0x21e <vTaskKeysLed+0x11a>
     21c:	bf cf       	rjmp	.-130    	; 0x19c <vTaskKeysLed+0x98>
				}
			
		if(KBD1==0x1F){ press=0; step=0; }
		KBD2=KBD1;
     21e:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <KBD2.1760>
		
		if( time_switch_mode ){ time_switch_mode--; }
     222:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <time_switch_mode.1762>
     226:	88 23       	and	r24, r24
     228:	21 f0       	breq	.+8      	; 0x232 <vTaskKeysLed+0x12e>
     22a:	81 50       	subi	r24, 0x01	; 1
     22c:	80 93 97 00 	sts	0x0097, r24	; 0x800097 <time_switch_mode.1762>
     230:	0d c0       	rjmp	.+26     	; 0x24c <vTaskKeysLed+0x148>
		else{
			if( mode == MODE_TEMP_MIN ){ mode=MODE_TEMP_MAX; time_switch_mode = 60; }
     232:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <mode>
     236:	81 30       	cpi	r24, 0x01	; 1
     238:	29 f4       	brne	.+10     	; 0x244 <vTaskKeysLed+0x140>
     23a:	f0 92 9e 00 	sts	0x009E, r15	; 0x80009e <mode>
     23e:	d0 93 97 00 	sts	0x0097, r29	; 0x800097 <time_switch_mode.1762>
     242:	04 c0       	rjmp	.+8      	; 0x24c <vTaskKeysLed+0x148>
			else if( mode == MODE_TEMP_MAX ){ mode=MODE_TEMP_ACT; }
     244:	82 30       	cpi	r24, 0x02	; 2
     246:	11 f4       	brne	.+4      	; 0x24c <vTaskKeysLed+0x148>
     248:	10 92 9e 00 	sts	0x009E, r1	; 0x80009e <mode>
		}

		switch( mode ){
     24c:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <mode>
     250:	82 30       	cpi	r24, 0x02	; 2
     252:	21 f1       	breq	.+72     	; 0x29c <vTaskKeysLed+0x198>
     254:	68 f4       	brcc	.+26     	; 0x270 <vTaskKeysLed+0x16c>
     256:	88 23       	and	r24, r24
     258:	c1 f0       	breq	.+48     	; 0x28a <vTaskKeysLed+0x186>
     25a:	81 30       	cpi	r24, 0x01	; 1
     25c:	89 f5       	brne	.+98     	; 0x2c0 <vTaskKeysLed+0x1bc>
			case MODE_TEMP_ACT:
				LED_PORT&=~LED1;	LED_PORT |=LED2|LED3|LED4|LED5; prvDisplayTemp(temp_act);
			break;
			case MODE_TEMP_MIN:
				LED_PORT&=~LED2;	LED_PORT |=LED1|LED3|LED4|LED5; prvDisplayTemp(temp_min);
     25e:	d9 98       	cbi	0x1b, 1	; 27
     260:	8b b3       	in	r24, 0x1b	; 27
     262:	8d 61       	ori	r24, 0x1D	; 29
     264:	8b bb       	out	0x1b, r24	; 27
     266:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <temp_min>
     26a:	90 91 d0 06 	lds	r25, 0x06D0	; 0x8006d0 <temp_min+0x1>
     26e:	27 c0       	rjmp	.+78     	; 0x2be <vTaskKeysLed+0x1ba>
		else{
			if( mode == MODE_TEMP_MIN ){ mode=MODE_TEMP_MAX; time_switch_mode = 60; }
			else if( mode == MODE_TEMP_MAX ){ mode=MODE_TEMP_ACT; }
		}

		switch( mode ){
     270:	83 30       	cpi	r24, 0x03	; 3
     272:	e9 f0       	breq	.+58     	; 0x2ae <vTaskKeysLed+0x1aa>
     274:	84 30       	cpi	r24, 0x04	; 4
     276:	21 f5       	brne	.+72     	; 0x2c0 <vTaskKeysLed+0x1bc>
			break;
			case MODE_TEMP_ALARM_MIN:
				LED_PORT&=~LED4;	LED_PORT |=LED1|LED2|LED3|LED5; prvDisplayTemp(temp_alarm_min);
			break;
			case MODE_TEMP_ALARM_MAX:
				LED_PORT&=~LED5;	LED_PORT |=LED1|LED2|LED3|LED4; prvDisplayTemp(temp_alarm_max);
     278:	dc 98       	cbi	0x1b, 4	; 27
     27a:	8b b3       	in	r24, 0x1b	; 27
     27c:	8f 60       	ori	r24, 0x0F	; 15
     27e:	8b bb       	out	0x1b, r24	; 27
     280:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     284:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     288:	1a c0       	rjmp	.+52     	; 0x2be <vTaskKeysLed+0x1ba>
			else if( mode == MODE_TEMP_MAX ){ mode=MODE_TEMP_ACT; }
		}

		switch( mode ){
			case MODE_TEMP_ACT:
				LED_PORT&=~LED1;	LED_PORT |=LED2|LED3|LED4|LED5; prvDisplayTemp(temp_act);
     28a:	d8 98       	cbi	0x1b, 0	; 27
     28c:	8b b3       	in	r24, 0x1b	; 27
     28e:	8e 61       	ori	r24, 0x1E	; 30
     290:	8b bb       	out	0x1b, r24	; 27
     292:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <temp_act>
     296:	90 91 d2 06 	lds	r25, 0x06D2	; 0x8006d2 <temp_act+0x1>
     29a:	11 c0       	rjmp	.+34     	; 0x2be <vTaskKeysLed+0x1ba>
			break;
			case MODE_TEMP_MIN:
				LED_PORT&=~LED2;	LED_PORT |=LED1|LED3|LED4|LED5; prvDisplayTemp(temp_min);
			break;
			case MODE_TEMP_MAX:
				LED_PORT&=~LED3;	LED_PORT |=LED1|LED2|LED4|LED5; prvDisplayTemp(temp_max);
     29c:	da 98       	cbi	0x1b, 2	; 27
     29e:	8b b3       	in	r24, 0x1b	; 27
     2a0:	8b 61       	ori	r24, 0x1B	; 27
     2a2:	8b bb       	out	0x1b, r24	; 27
     2a4:	80 91 cd 06 	lds	r24, 0x06CD	; 0x8006cd <temp_max>
     2a8:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <temp_max+0x1>
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <vTaskKeysLed+0x1ba>
			break;
			case MODE_TEMP_ALARM_MIN:
				LED_PORT&=~LED4;	LED_PORT |=LED1|LED2|LED3|LED5; prvDisplayTemp(temp_alarm_min);
     2ae:	db 98       	cbi	0x1b, 3	; 27
     2b0:	8b b3       	in	r24, 0x1b	; 27
     2b2:	87 61       	ori	r24, 0x17	; 23
     2b4:	8b bb       	out	0x1b, r24	; 27
     2b6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <temp_alarm_min>
     2ba:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <temp_alarm_min+0x1>
			break;
			case MODE_TEMP_ALARM_MAX:
				LED_PORT&=~LED5;	LED_PORT |=LED1|LED2|LED3|LED4; prvDisplayTemp(temp_alarm_max);
     2be:	ec de       	rcall	.-552    	; 0x98 <prvDisplayTemp>
			break;
		}
		if( (temp_act<temp_alarm_min) || (temp_act>temp_alarm_max) ){ LED_PORT&=~LED6; }
     2c0:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <temp_act>
     2c4:	90 91 d2 06 	lds	r25, 0x06D2	; 0x8006d2 <temp_act+0x1>
     2c8:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <temp_alarm_min>
     2cc:	30 91 63 00 	lds	r19, 0x0063	; 0x800063 <temp_alarm_min+0x1>
     2d0:	82 17       	cp	r24, r18
     2d2:	93 07       	cpc	r25, r19
     2d4:	3c f0       	brlt	.+14     	; 0x2e4 <vTaskKeysLed+0x1e0>
     2d6:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     2da:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     2de:	28 17       	cp	r18, r24
     2e0:	39 07       	cpc	r19, r25
     2e2:	14 f4       	brge	.+4      	; 0x2e8 <vTaskKeysLed+0x1e4>
     2e4:	dd 98       	cbi	0x1b, 5	; 27
     2e6:	01 c0       	rjmp	.+2      	; 0x2ea <vTaskKeysLed+0x1e6>
		else{ LED_PORT |=LED6; }
     2e8:	dd 9a       	sbi	0x1b, 5	; 27

		vTaskDelay( 50 / portTICK_RATE_MS );
     2ea:	82 e3       	ldi	r24, 0x32	; 50
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	0e 94 ce 0a 	call	0x159c	; 0x159c <vTaskDelay>
	}
     2f2:	0e cf       	rjmp	.-484    	; 0x110 <vTaskKeysLed+0xc>
						}						
					}
					if(step<21){ step++; }
				}
			
		if(KBD1==0x1F){ press=0; step=0; }
     2f4:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <press.1761>
     2f8:	10 92 96 00 	sts	0x0096, r1	; 0x800096 <__data_end>
     2fc:	90 cf       	rjmp	.-224    	; 0x21e <vTaskKeysLed+0x11a>

000002fe <vTaskMeasTemp>:
	}
}
//pomiar temperatury
static void vTaskMeasTemp(void *pvParameters);
static void vTaskMeasTemp(void *pvParameters)
{
     2fe:	cf 93       	push	r28
     300:	df 93       	push	r29
     302:	00 d0       	rcall	.+0      	; 0x304 <vTaskMeasTemp+0x6>
     304:	1f 92       	push	r1
     306:	cd b7       	in	r28, 0x3d	; 61
     308:	de b7       	in	r29, 0x3e	; 62
	uint8_t sign, integer, fraction;
	for( ;; )
	{
		if (xSemaphoreTake(Tim2s, portMAX_DELAY)){
     30a:	20 e0       	ldi	r18, 0x00	; 0
     30c:	4f ef       	ldi	r20, 0xFF	; 255
     30e:	5f ef       	ldi	r21, 0xFF	; 255
     310:	60 e0       	ldi	r22, 0x00	; 0
     312:	70 e0       	ldi	r23, 0x00	; 0
     314:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <Tim2s>
     318:	90 91 9d 00 	lds	r25, 0x009D	; 0x80009d <Tim2s+0x1>
     31c:	55 d6       	rcall	.+3242   	; 0xfc8 <xQueueGenericReceive>
     31e:	88 23       	and	r24, r24
     320:	a1 f3       	breq	.-24     	; 0x30a <vTaskMeasTemp+0xc>
			DS18X20_start_meas( DS18X20_POWER_EXTERN, NULL );
     322:	60 e0       	ldi	r22, 0x00	; 0
     324:	70 e0       	ldi	r23, 0x00	; 0
     326:	81 e0       	ldi	r24, 0x01	; 1
     328:	d6 d1       	rcall	.+940    	; 0x6d6 <DS18X20_start_meas>
			vTaskDelay( 1000/portTICK_RATE_MS );
     32a:	88 ee       	ldi	r24, 0xE8	; 232
     32c:	93 e0       	ldi	r25, 0x03	; 3
     32e:	0e 94 ce 0a 	call	0x159c	; 0x159c <vTaskDelay>
			if( DS18X20_OK == DS18X20_read_meas(gSensorIDs[0], &sign, &integer, &fraction) ) {
     332:	9e 01       	movw	r18, r28
     334:	2f 5f       	subi	r18, 0xFF	; 255
     336:	3f 4f       	sbci	r19, 0xFF	; 255
     338:	ae 01       	movw	r20, r28
     33a:	4e 5f       	subi	r20, 0xFE	; 254
     33c:	5f 4f       	sbci	r21, 0xFF	; 255
     33e:	be 01       	movw	r22, r28
     340:	6d 5f       	subi	r22, 0xFD	; 253
     342:	7f 4f       	sbci	r23, 0xFF	; 255
     344:	89 ed       	ldi	r24, 0xD9	; 217
     346:	96 e0       	ldi	r25, 0x06	; 6
     348:	e3 d1       	rcall	.+966    	; 0x710 <DS18X20_read_meas>
     34a:	81 11       	cpse	r24, r1
     34c:	de cf       	rjmp	.-68     	; 0x30a <vTaskMeasTemp+0xc>
				temp_act = ((uint16_t)integer*10) + fraction;
     34e:	2a 81       	ldd	r18, Y+2	; 0x02
     350:	89 81       	ldd	r24, Y+1	; 0x01
     352:	90 e0       	ldi	r25, 0x00	; 0
     354:	3a e0       	ldi	r19, 0x0A	; 10
     356:	23 9f       	mul	r18, r19
     358:	80 0d       	add	r24, r0
     35a:	91 1d       	adc	r25, r1
     35c:	11 24       	eor	r1, r1
     35e:	90 93 d2 06 	sts	0x06D2, r25	; 0x8006d2 <temp_act+0x1>
     362:	80 93 d1 06 	sts	0x06D1, r24	; 0x8006d1 <temp_act>
				if(sign==1){ temp_act*=-1; }
     366:	2b 81       	ldd	r18, Y+3	; 0x03
     368:	21 30       	cpi	r18, 0x01	; 1
     36a:	39 f4       	brne	.+14     	; 0x37a <vTaskMeasTemp+0x7c>
     36c:	91 95       	neg	r25
     36e:	81 95       	neg	r24
     370:	91 09       	sbc	r25, r1
     372:	90 93 d2 06 	sts	0x06D2, r25	; 0x8006d2 <temp_act+0x1>
     376:	80 93 d1 06 	sts	0x06D1, r24	; 0x8006d1 <temp_act>
				//prvDisplayTemp(temp_act);
				if ( first_temp==0 )
     37a:	20 91 d4 06 	lds	r18, 0x06D4	; 0x8006d4 <first_temp>
     37e:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <temp_act>
     382:	90 91 d2 06 	lds	r25, 0x06D2	; 0x8006d2 <temp_act+0x1>
     386:	21 11       	cpse	r18, r1
     388:	0c c0       	rjmp	.+24     	; 0x3a2 <vTaskMeasTemp+0xa4>
				{
					temp_min=temp_act;
     38a:	90 93 d0 06 	sts	0x06D0, r25	; 0x8006d0 <temp_min+0x1>
     38e:	80 93 cf 06 	sts	0x06CF, r24	; 0x8006cf <temp_min>
					temp_max=temp_act;
     392:	90 93 ce 06 	sts	0x06CE, r25	; 0x8006ce <temp_max+0x1>
     396:	80 93 cd 06 	sts	0x06CD, r24	; 0x8006cd <temp_max>
					first_temp=1;
     39a:	81 e0       	ldi	r24, 0x01	; 1
     39c:	80 93 d4 06 	sts	0x06D4, r24	; 0x8006d4 <first_temp>
     3a0:	b4 cf       	rjmp	.-152    	; 0x30a <vTaskMeasTemp+0xc>
				}
				else{
				if( temp_act < temp_min ){ temp_min = temp_act; }
     3a2:	20 91 cf 06 	lds	r18, 0x06CF	; 0x8006cf <temp_min>
     3a6:	30 91 d0 06 	lds	r19, 0x06D0	; 0x8006d0 <temp_min+0x1>
     3aa:	82 17       	cp	r24, r18
     3ac:	93 07       	cpc	r25, r19
     3ae:	24 f4       	brge	.+8      	; 0x3b8 <vTaskMeasTemp+0xba>
     3b0:	90 93 d0 06 	sts	0x06D0, r25	; 0x8006d0 <temp_min+0x1>
     3b4:	80 93 cf 06 	sts	0x06CF, r24	; 0x8006cf <temp_min>
				if( temp_act > temp_max ){ temp_max = temp_act; }					
     3b8:	20 91 cd 06 	lds	r18, 0x06CD	; 0x8006cd <temp_max>
     3bc:	30 91 ce 06 	lds	r19, 0x06CE	; 0x8006ce <temp_max+0x1>
     3c0:	28 17       	cp	r18, r24
     3c2:	39 07       	cpc	r19, r25
     3c4:	0c f0       	brlt	.+2      	; 0x3c8 <vTaskMeasTemp+0xca>
     3c6:	a1 cf       	rjmp	.-190    	; 0x30a <vTaskMeasTemp+0xc>
     3c8:	90 93 ce 06 	sts	0x06CE, r25	; 0x8006ce <temp_max+0x1>
     3cc:	80 93 cd 06 	sts	0x06CD, r24	; 0x8006cd <temp_max>
     3d0:	9c cf       	rjmp	.-200    	; 0x30a <vTaskMeasTemp+0xc>

000003d2 <__vector_10>:
	search_sensors();
}


ISR(TIMER0_COMP_vect) // wywolywane co ok. 2ms
{
     3d2:	1f 92       	push	r1
     3d4:	0f 92       	push	r0
     3d6:	0f b6       	in	r0, 0x3f	; 63
     3d8:	0f 92       	push	r0
     3da:	11 24       	eor	r1, r1
     3dc:	2f 93       	push	r18
     3de:	3f 93       	push	r19
     3e0:	4f 93       	push	r20
     3e2:	5f 93       	push	r21
     3e4:	6f 93       	push	r22
     3e6:	7f 93       	push	r23
     3e8:	8f 93       	push	r24
     3ea:	9f 93       	push	r25
     3ec:	af 93       	push	r26
     3ee:	bf 93       	push	r27
     3f0:	ef 93       	push	r30
     3f2:	ff 93       	push	r31
     3f4:	cf 93       	push	r28
     3f6:	df 93       	push	r29
     3f8:	1f 92       	push	r1
     3fa:	cd b7       	in	r28, 0x3d	; 61
     3fc:	de b7       	in	r29, 0x3e	; 62
	static uint16_t t = 0;
	
	signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     3fe:	19 82       	std	Y+1, r1	; 0x01

	// obsluga odmierzania czasu 1s
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	if (t++ > 500)
     400:	80 91 9a 00 	lds	r24, 0x009A	; 0x80009a <t.1752>
     404:	90 91 9b 00 	lds	r25, 0x009B	; 0x80009b <t.1752+0x1>
     408:	85 3f       	cpi	r24, 0xF5	; 245
     40a:	21 e0       	ldi	r18, 0x01	; 1
     40c:	92 07       	cpc	r25, r18
     40e:	30 f4       	brcc	.+12     	; 0x41c <__EEPROM_REGION_LENGTH__+0x1c>
     410:	01 96       	adiw	r24, 0x01	; 1
     412:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <t.1752+0x1>
     416:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <t.1752>
     41a:	0f c0       	rjmp	.+30     	; 0x43a <__EEPROM_REGION_LENGTH__+0x3a>
	{
		t = 0;
     41c:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <t.1752+0x1>
     420:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <t.1752>
		xSemaphoreGiveFromISR(Tim2s, &xHigherPriorityTaskWoken);
     424:	20 e0       	ldi	r18, 0x00	; 0
     426:	ae 01       	movw	r20, r28
     428:	4f 5f       	subi	r20, 0xFF	; 255
     42a:	5f 4f       	sbci	r21, 0xFF	; 255
     42c:	60 e0       	ldi	r22, 0x00	; 0
     42e:	70 e0       	ldi	r23, 0x00	; 0
     430:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <Tim2s>
     434:	90 91 9d 00 	lds	r25, 0x009D	; 0x80009d <Tim2s+0x1>
     438:	a1 d5       	rcall	.+2882   	; 0xf7c <xQueueGenericSendFromISR>
	}
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	// obsluga wyswietlacza siedmiosegmentowego LED
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    if ((++LED_ptr) > NUMBER_OF_DIGITS-1) LED_ptr = 0;
     43a:	80 91 d3 06 	lds	r24, 0x06D3	; 0x8006d3 <LED_ptr>
     43e:	8f 5f       	subi	r24, 0xFF	; 255
     440:	80 93 d3 06 	sts	0x06D3, r24	; 0x8006d3 <LED_ptr>
     444:	84 30       	cpi	r24, 0x04	; 4
     446:	10 f0       	brcs	.+4      	; 0x44c <__EEPROM_REGION_LENGTH__+0x4c>
     448:	10 92 d3 06 	sts	0x06D3, r1	; 0x8006d3 <LED_ptr>
	LED_digits |= 0x0F;
     44c:	88 b3       	in	r24, 0x18	; 24
     44e:	8f 60       	ori	r24, 0x0F	; 15
     450:	88 bb       	out	0x18, r24	; 24
	LED_segments = ~LED_buf[LED_ptr]; 
     452:	e0 91 d3 06 	lds	r30, 0x06D3	; 0x8006d3 <LED_ptr>
     456:	f0 e0       	ldi	r31, 0x00	; 0
     458:	eb 52       	subi	r30, 0x2B	; 43
     45a:	f9 4f       	sbci	r31, 0xF9	; 249
     45c:	80 81       	ld	r24, Z
     45e:	80 95       	com	r24
     460:	85 bb       	out	0x15, r24	; 21
	LED_digits &=~(1<<LED_ptr);
     462:	30 91 d3 06 	lds	r19, 0x06D3	; 0x8006d3 <LED_ptr>
     466:	28 b3       	in	r18, 0x18	; 24
     468:	81 e0       	ldi	r24, 0x01	; 1
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	02 c0       	rjmp	.+4      	; 0x472 <__EEPROM_REGION_LENGTH__+0x72>
     46e:	88 0f       	add	r24, r24
     470:	99 1f       	adc	r25, r25
     472:	3a 95       	dec	r19
     474:	e2 f7       	brpl	.-8      	; 0x46e <__EEPROM_REGION_LENGTH__+0x6e>
     476:	80 95       	com	r24
     478:	90 95       	com	r25
     47a:	82 23       	and	r24, r18
     47c:	88 bb       	out	0x18, r24	; 24
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	if (xHigherPriorityTaskWoken == pdTRUE) taskYIELD();
     47e:	89 81       	ldd	r24, Y+1	; 0x01
     480:	81 30       	cpi	r24, 0x01	; 1
     482:	09 f4       	brne	.+2      	; 0x486 <__EEPROM_REGION_LENGTH__+0x86>
     484:	a2 d3       	rcall	.+1860   	; 0xbca <vPortYield>
}
     486:	0f 90       	pop	r0
     488:	df 91       	pop	r29
     48a:	cf 91       	pop	r28
     48c:	ff 91       	pop	r31
     48e:	ef 91       	pop	r30
     490:	bf 91       	pop	r27
     492:	af 91       	pop	r26
     494:	9f 91       	pop	r25
     496:	8f 91       	pop	r24
     498:	7f 91       	pop	r23
     49a:	6f 91       	pop	r22
     49c:	5f 91       	pop	r21
     49e:	4f 91       	pop	r20
     4a0:	3f 91       	pop	r19
     4a2:	2f 91       	pop	r18
     4a4:	0f 90       	pop	r0
     4a6:	0f be       	out	0x3f, r0	; 63
     4a8:	0f 90       	pop	r0
     4aa:	1f 90       	pop	r1
     4ac:	18 95       	reti

000004ae <main>:

static void prvInitHardware(void);
static void prvInitHardware(void)
{
	// porty wyswietlacza LED
	DDRB |= 0x0F;
     4ae:	87 b3       	in	r24, 0x17	; 23
     4b0:	8f 60       	ori	r24, 0x0F	; 15
     4b2:	87 bb       	out	0x17, r24	; 23
	PORTB &= ~0x0F;
     4b4:	88 b3       	in	r24, 0x18	; 24
     4b6:	80 7f       	andi	r24, 0xF0	; 240
     4b8:	88 bb       	out	0x18, r24	; 24
	DDRC = 0xFF;
     4ba:	8f ef       	ldi	r24, 0xFF	; 255
     4bc:	84 bb       	out	0x14, r24	; 20
	PORTC = 0x00;
     4be:	15 ba       	out	0x15, r1	; 21

	//pull up pinów pod³¹czonych do przycisków
	PORTD|=KEY1|KEY2|KEY3|KEY4|KEY5;
     4c0:	82 b3       	in	r24, 0x12	; 18
     4c2:	8f 61       	ori	r24, 0x1F	; 31
     4c4:	82 bb       	out	0x12, r24	; 18

	//diody led
	DDRA|=LED1|LED2|LED3|LED4|LED5|LED6;
     4c6:	8a b3       	in	r24, 0x1a	; 26
     4c8:	8f 63       	ori	r24, 0x3F	; 63
     4ca:	8a bb       	out	0x1a, r24	; 26
	LED_PORT |=(LED1|LED2|LED3|LED4|LED5|LED6);
     4cc:	8b b3       	in	r24, 0x1b	; 27
     4ce:	8f 63       	ori	r24, 0x3F	; 63
     4d0:	8b bb       	out	0x1b, r24	; 27

	// inicjalizacja licznika Timer0 i przerwania F_CPU=16MHz
    TIMSK |= (1<<OCIE0);
     4d2:	89 b7       	in	r24, 0x39	; 57
     4d4:	82 60       	ori	r24, 0x02	; 2
     4d6:	89 bf       	out	0x39, r24	; 57
    OCR0 = 30; //2ms
     4d8:	8e e1       	ldi	r24, 0x1E	; 30
     4da:	8c bf       	out	0x3c, r24	; 60
	// Prescaler = 1024 
    TCCR0 |= (1<<WGM01) | (1<<CS02) | (0<<CS01) | (1<<CS00);
     4dc:	83 b7       	in	r24, 0x33	; 51
     4de:	8d 60       	ori	r24, 0x0D	; 13
     4e0:	83 bf       	out	0x33, r24	; 51
	
	search_sensors();
     4e2:	be d0       	rcall	.+380    	; 0x660 <search_sensors>

void main(void)
{
	prvInitHardware();

	vSemaphoreCreateBinary(Tim2s);
     4e4:	60 e0       	ldi	r22, 0x00	; 0
     4e6:	81 e0       	ldi	r24, 0x01	; 1
     4e8:	7d d4       	rcall	.+2298   	; 0xde4 <xQueueCreate>
     4ea:	90 93 9d 00 	sts	0x009D, r25	; 0x80009d <Tim2s+0x1>
     4ee:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <Tim2s>
     4f2:	00 97       	sbiw	r24, 0x00	; 0
     4f4:	31 f0       	breq	.+12     	; 0x502 <main+0x54>
     4f6:	20 e0       	ldi	r18, 0x00	; 0
     4f8:	40 e0       	ldi	r20, 0x00	; 0
     4fa:	50 e0       	ldi	r21, 0x00	; 0
     4fc:	60 e0       	ldi	r22, 0x00	; 0
     4fe:	70 e0       	ldi	r23, 0x00	; 0
     500:	b7 d4       	rcall	.+2414   	; 0xe70 <xQueueGenericSend>

	xTaskCreate( vTaskMeasTemp, 
     502:	a1 2c       	mov	r10, r1
     504:	b1 2c       	mov	r11, r1
     506:	c1 2c       	mov	r12, r1
     508:	d1 2c       	mov	r13, r1
     50a:	e1 2c       	mov	r14, r1
     50c:	f1 2c       	mov	r15, r1
     50e:	02 e0       	ldi	r16, 0x02	; 2
     510:	20 e0       	ldi	r18, 0x00	; 0
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	45 e5       	ldi	r20, 0x55	; 85
     516:	50 e0       	ldi	r21, 0x00	; 0
     518:	66 e7       	ldi	r22, 0x76	; 118
     51a:	70 e0       	ldi	r23, 0x00	; 0
     51c:	8f e7       	ldi	r24, 0x7F	; 127
     51e:	91 e0       	ldi	r25, 0x01	; 1
     520:	20 d6       	rcall	.+3136   	; 0x1162 <xTaskGenericCreate>
				 configMINIMAL_STACK_SIZE,
				 NULL,
				 DS18B20_TASK_PRIORITY,
				 NULL);
				 
	xTaskCreate( vTaskKeysLed,
     522:	01 e0       	ldi	r16, 0x01	; 1
     524:	20 e0       	ldi	r18, 0x00	; 0
     526:	30 e0       	ldi	r19, 0x00	; 0
     528:	45 e5       	ldi	r20, 0x55	; 85
     52a:	50 e0       	ldi	r21, 0x00	; 0
     52c:	64 e8       	ldi	r22, 0x84	; 132
     52e:	70 e0       	ldi	r23, 0x00	; 0
     530:	82 e8       	ldi	r24, 0x82	; 130
     532:	90 e0       	ldi	r25, 0x00	; 0
				configMINIMAL_STACK_SIZE,
				NULL,
				KEYS_TASK_PRIORITY,
				NULL);

	vTaskStartScheduler();
     534:	16 d6       	rcall	.+3116   	; 0x1162 <xTaskGenericCreate>
     536:	f7 d6       	rcall	.+3566   	; 0x1326 <vTaskStartScheduler>
     538:	ff cf       	rjmp	.-2      	; 0x538 <main+0x8a>

0000053a <crc8>:

#define CRC8INIT	0x00
#define CRC8POLY	0x18              //0X18 = X^8+X^5+X^4+X^0

uint8_t	crc8 ( uint8_t *data_in, uint16_t number_of_bytes_to_read )
{
     53a:	fc 01       	movw	r30, r24
     53c:	68 0f       	add	r22, r24
     53e:	79 1f       	adc	r23, r25
	uint16_t loop_count;
	uint8_t  bit_counter;
	uint8_t  data;
	uint8_t  feedback_bit;

	crc = CRC8INIT;
     540:	80 e0       	ldi	r24, 0x00	; 0
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ data) & 0x01;

			if ( feedback_bit == 0x01 ) {
				crc = crc ^ CRC8POLY;
     542:	48 e1       	ldi	r20, 0x18	; 24
	uint8_t  data;
	uint8_t  feedback_bit;

	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_to_read; loop_count++)
     544:	e6 17       	cp	r30, r22
     546:	f7 07       	cpc	r31, r23
     548:	81 f0       	breq	.+32     	; 0x56a <crc8+0x30>
	{
		data = data_in[loop_count];
     54a:	21 91       	ld	r18, Z+
     54c:	98 e0       	ldi	r25, 0x08	; 8

		bit_counter = 8;
		do {
			feedback_bit = (crc ^ data) & 0x01;
     54e:	38 2f       	mov	r19, r24
     550:	32 27       	eor	r19, r18

			if ( feedback_bit == 0x01 ) {
     552:	53 2f       	mov	r21, r19
     554:	51 70       	andi	r21, 0x01	; 1
     556:	30 fd       	sbrc	r19, 0
				crc = crc ^ CRC8POLY;
     558:	84 27       	eor	r24, r20
			}
			crc = (crc >> 1) & 0x7F;
     55a:	86 95       	lsr	r24
			if ( feedback_bit == 0x01 ) {
     55c:	51 30       	cpi	r21, 0x01	; 1
     55e:	09 f4       	brne	.+2      	; 0x562 <crc8+0x28>
				crc = crc | 0x80;
     560:	80 68       	ori	r24, 0x80	; 128
			}

			data = data >> 1;
     562:	26 95       	lsr	r18
     564:	91 50       	subi	r25, 0x01	; 1
			bit_counter--;

		} while (bit_counter > 0);
     566:	99 f7       	brne	.-26     	; 0x54e <crc8+0x14>
     568:	ed cf       	rjmp	.-38     	; 0x544 <crc8+0xa>
	}

	return crc;
}
     56a:	08 95       	ret

0000056c <DS18X20_meas_to_cel>:
	if( ow_reset() ) return DS18X20_ERROR;
    ow_command(DS18X20_READ_POWER_SUPPLY, id);
    pstat=ow_bit_io(1); // pstat 0=is parasite/ !=0 ext. powered
    ow_reset();
	return (pstat) ? DS18X20_POWER_EXTERN:DS18X20_POWER_PARASITE;
}
     56c:	0f 93       	push	r16
     56e:	1f 93       	push	r17
     570:	cf 93       	push	r28
     572:	df 93       	push	r29
     574:	cd b7       	in	r28, 0x3d	; 61
     576:	de b7       	in	r29, 0x3e	; 62
     578:	60 97       	sbiw	r28, 0x10	; 16
     57a:	0f b6       	in	r0, 0x3f	; 63
     57c:	f8 94       	cli
     57e:	de bf       	out	0x3e, r29	; 62
     580:	0f be       	out	0x3f, r0	; 63
     582:	cd bf       	out	0x3d, r28	; 61
     584:	90 e1       	ldi	r25, 0x10	; 16
     586:	e6 e6       	ldi	r30, 0x66	; 102
     588:	f0 e0       	ldi	r31, 0x00	; 0
     58a:	de 01       	movw	r26, r28
     58c:	11 96       	adiw	r26, 0x01	; 1
     58e:	01 90       	ld	r0, Z+
     590:	0d 92       	st	X+, r0
     592:	9a 95       	dec	r25
     594:	e1 f7       	brne	.-8      	; 0x58e <DS18X20_meas_to_cel+0x22>
     596:	db 01       	movw	r26, r22
     598:	ed 91       	ld	r30, X+
     59a:	fc 91       	ld	r31, X
     59c:	11 97       	sbiw	r26, 0x01	; 1
     59e:	80 31       	cpi	r24, 0x10	; 16
     5a0:	59 f4       	brne	.+22     	; 0x5b8 <DS18X20_meas_to_cel+0x4c>
     5a2:	ee 7f       	andi	r30, 0xFE	; 254
     5a4:	93 e0       	ldi	r25, 0x03	; 3
     5a6:	ee 0f       	add	r30, r30
     5a8:	ff 1f       	adc	r31, r31
     5aa:	9a 95       	dec	r25
     5ac:	e1 f7       	brne	.-8      	; 0x5a6 <DS18X20_meas_to_cel+0x3a>
     5ae:	16 96       	adiw	r26, 0x06	; 6
     5b0:	9c 91       	ld	r25, X
     5b2:	e9 1b       	sub	r30, r25
     5b4:	f1 09       	sbc	r31, r1
     5b6:	3c 96       	adiw	r30, 0x0c	; 12
     5b8:	f7 ff       	sbrs	r31, 7
     5ba:	07 c0       	rjmp	.+14     	; 0x5ca <DS18X20_meas_to_cel+0x5e>
     5bc:	91 e0       	ldi	r25, 0x01	; 1
     5be:	da 01       	movw	r26, r20
     5c0:	9c 93       	st	X, r25
     5c2:	f1 95       	neg	r31
     5c4:	e1 95       	neg	r30
     5c6:	f1 09       	sbc	r31, r1
     5c8:	02 c0       	rjmp	.+4      	; 0x5ce <DS18X20_meas_to_cel+0x62>
     5ca:	da 01       	movw	r26, r20
     5cc:	1c 92       	st	X, r1
     5ce:	88 32       	cpi	r24, 0x28	; 40
     5d0:	81 f4       	brne	.+32     	; 0x5f2 <DS18X20_meas_to_cel+0x86>
     5d2:	db 01       	movw	r26, r22
     5d4:	14 96       	adiw	r26, 0x04	; 4
     5d6:	8c 91       	ld	r24, X
     5d8:	98 2f       	mov	r25, r24
     5da:	90 76       	andi	r25, 0x60	; 96
     5dc:	90 36       	cpi	r25, 0x60	; 96
     5de:	49 f0       	breq	.+18     	; 0x5f2 <DS18X20_meas_to_cel+0x86>
     5e0:	86 ff       	sbrs	r24, 6
     5e2:	02 c0       	rjmp	.+4      	; 0x5e8 <DS18X20_meas_to_cel+0x7c>
     5e4:	ee 7f       	andi	r30, 0xFE	; 254
     5e6:	05 c0       	rjmp	.+10     	; 0x5f2 <DS18X20_meas_to_cel+0x86>
     5e8:	85 ff       	sbrs	r24, 5
     5ea:	02 c0       	rjmp	.+4      	; 0x5f0 <DS18X20_meas_to_cel+0x84>
     5ec:	ec 7f       	andi	r30, 0xFC	; 252
     5ee:	01 c0       	rjmp	.+2      	; 0x5f2 <DS18X20_meas_to_cel+0x86>
     5f0:	e8 7f       	andi	r30, 0xF8	; 248
     5f2:	cf 01       	movw	r24, r30
     5f4:	44 e0       	ldi	r20, 0x04	; 4
     5f6:	96 95       	lsr	r25
     5f8:	87 95       	ror	r24
     5fa:	4a 95       	dec	r20
     5fc:	e1 f7       	brne	.-8      	; 0x5f6 <DS18X20_meas_to_cel+0x8a>
     5fe:	d9 01       	movw	r26, r18
     600:	8c 93       	st	X, r24
     602:	ef 70       	andi	r30, 0x0F	; 15
     604:	ff 27       	eor	r31, r31
     606:	81 e0       	ldi	r24, 0x01	; 1
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	8c 0f       	add	r24, r28
     60c:	9d 1f       	adc	r25, r29
     60e:	e8 0f       	add	r30, r24
     610:	f9 1f       	adc	r31, r25
     612:	80 81       	ld	r24, Z
     614:	d8 01       	movw	r26, r16
     616:	8c 93       	st	X, r24
     618:	80 e0       	ldi	r24, 0x00	; 0
     61a:	60 96       	adiw	r28, 0x10	; 16
     61c:	0f b6       	in	r0, 0x3f	; 63
     61e:	f8 94       	cli
     620:	de bf       	out	0x3e, r29	; 62
     622:	0f be       	out	0x3f, r0	; 63
     624:	cd bf       	out	0x3d, r28	; 61
     626:	df 91       	pop	r29
     628:	cf 91       	pop	r28
     62a:	1f 91       	pop	r17
     62c:	0f 91       	pop	r16
     62e:	08 95       	ret

00000630 <DS18X20_find_sensor>:
     630:	0f 93       	push	r16
     632:	1f 93       	push	r17
     634:	cf 93       	push	r28
     636:	df 93       	push	r29
     638:	ec 01       	movw	r28, r24
     63a:	8b 01       	movw	r16, r22
     63c:	b8 01       	movw	r22, r16
     63e:	88 81       	ld	r24, Y
     640:	97 d1       	rcall	.+814    	; 0x970 <ow_rom_search>
     642:	88 83       	st	Y, r24
     644:	81 50       	subi	r24, 0x01	; 1
     646:	8d 3f       	cpi	r24, 0xFD	; 253
     648:	30 f4       	brcc	.+12     	; 0x656 <DS18X20_find_sensor+0x26>
     64a:	f8 01       	movw	r30, r16
     64c:	80 81       	ld	r24, Z
     64e:	88 32       	cpi	r24, 0x28	; 40
     650:	11 f0       	breq	.+4      	; 0x656 <DS18X20_find_sensor+0x26>
     652:	80 31       	cpi	r24, 0x10	; 16
     654:	99 f7       	brne	.-26     	; 0x63c <DS18X20_find_sensor+0xc>
     656:	df 91       	pop	r29
     658:	cf 91       	pop	r28
     65a:	1f 91       	pop	r17
     65c:	0f 91       	pop	r16
     65e:	08 95       	ret

00000660 <search_sensors>:
     660:	ef 92       	push	r14
     662:	ff 92       	push	r15
     664:	1f 93       	push	r17
     666:	cf 93       	push	r28
     668:	df 93       	push	r29
     66a:	cd b7       	in	r28, 0x3d	; 61
     66c:	de b7       	in	r29, 0x3e	; 62
     66e:	29 97       	sbiw	r28, 0x09	; 9
     670:	0f b6       	in	r0, 0x3f	; 63
     672:	f8 94       	cli
     674:	de bf       	out	0x3e, r29	; 62
     676:	0f be       	out	0x3f, r0	; 63
     678:	cd bf       	out	0x3d, r28	; 61
     67a:	8f ef       	ldi	r24, 0xFF	; 255
     67c:	89 87       	std	Y+9, r24	; 0x09
     67e:	10 e0       	ldi	r17, 0x00	; 0
     680:	7e 01       	movw	r14, r28
     682:	89 e0       	ldi	r24, 0x09	; 9
     684:	e8 0e       	add	r14, r24
     686:	f1 1c       	adc	r15, r1
     688:	89 85       	ldd	r24, Y+9	; 0x09
     68a:	88 23       	and	r24, r24
     68c:	b9 f0       	breq	.+46     	; 0x6bc <search_sensors+0x5c>
     68e:	11 11       	cpse	r17, r1
     690:	14 c0       	rjmp	.+40     	; 0x6ba <search_sensors+0x5a>
     692:	be 01       	movw	r22, r28
     694:	6f 5f       	subi	r22, 0xFF	; 255
     696:	7f 4f       	sbci	r23, 0xFF	; 255
     698:	c7 01       	movw	r24, r14
     69a:	ca df       	rcall	.-108    	; 0x630 <DS18X20_find_sensor>
     69c:	89 85       	ldd	r24, Y+9	; 0x09
     69e:	8e 5f       	subi	r24, 0xFE	; 254
     6a0:	82 30       	cpi	r24, 0x02	; 2
     6a2:	60 f0       	brcs	.+24     	; 0x6bc <search_sensors+0x5c>
     6a4:	fe 01       	movw	r30, r28
     6a6:	31 96       	adiw	r30, 0x01	; 1
     6a8:	a9 ed       	ldi	r26, 0xD9	; 217
     6aa:	b6 e0       	ldi	r27, 0x06	; 6
     6ac:	81 91       	ld	r24, Z+
     6ae:	8d 93       	st	X+, r24
     6b0:	11 e0       	ldi	r17, 0x01	; 1
     6b2:	ee 15       	cp	r30, r14
     6b4:	ff 05       	cpc	r31, r15
     6b6:	d1 f7       	brne	.-12     	; 0x6ac <search_sensors+0x4c>
     6b8:	e7 cf       	rjmp	.-50     	; 0x688 <search_sensors+0x28>
     6ba:	11 e0       	ldi	r17, 0x01	; 1
     6bc:	81 2f       	mov	r24, r17
     6be:	29 96       	adiw	r28, 0x09	; 9
     6c0:	0f b6       	in	r0, 0x3f	; 63
     6c2:	f8 94       	cli
     6c4:	de bf       	out	0x3e, r29	; 62
     6c6:	0f be       	out	0x3f, r0	; 63
     6c8:	cd bf       	out	0x3d, r28	; 61
     6ca:	df 91       	pop	r29
     6cc:	cf 91       	pop	r28
     6ce:	1f 91       	pop	r17
     6d0:	ff 90       	pop	r15
     6d2:	ef 90       	pop	r14
     6d4:	08 95       	ret

000006d6 <DS18X20_start_meas>:

/* start measurement (CONVERT_T) for all sensors if input id==NULL
   or for single sensor. then id is the rom-code */
uint8_t DS18X20_start_meas( uint8_t with_power_extern, uint8_t id[])
{
     6d6:	0f 93       	push	r16
     6d8:	1f 93       	push	r17
     6da:	cf 93       	push	r28
     6dc:	df 93       	push	r29
     6de:	d8 2f       	mov	r29, r24
     6e0:	8b 01       	movw	r16, r22
	if( ow_reset() ) return DS18X20_ERROR;
     6e2:	08 d1       	rcall	.+528    	; 0x8f4 <ow_reset>
     6e4:	c8 2f       	mov	r28, r24
     6e6:	81 11       	cpse	r24, r1
     6e8:	0a c0       	rjmp	.+20     	; 0x6fe <DS18X20_start_meas+0x28>

	if( ow_input_pin_state() ) { // only send if bus is "idle" = high
     6ea:	fe d0       	rcall	.+508    	; 0x8e8 <ow_input_pin_state>
     6ec:	88 23       	and	r24, r24
     6ee:	49 f0       	breq	.+18     	; 0x702 <DS18X20_start_meas+0x2c>
     6f0:	b8 01       	movw	r22, r16
		ow_command( DS18X20_CONVERT_T, id );
     6f2:	84 e4       	ldi	r24, 0x44	; 68
     6f4:	85 d1       	rcall	.+778    	; 0xa00 <ow_command>
     6f6:	d1 30       	cpi	r29, 0x01	; 1
		if (with_power_extern != DS18X20_POWER_EXTERN)
     6f8:	29 f0       	breq	.+10     	; 0x704 <DS18X20_start_meas+0x2e>
     6fa:	f9 d0       	rcall	.+498    	; 0x8ee <ow_parasite_enable>
			ow_parasite_enable();
     6fc:	03 c0       	rjmp	.+6      	; 0x704 <DS18X20_start_meas+0x2e>
     6fe:	c1 e0       	ldi	r28, 0x01	; 1
     700:	01 c0       	rjmp	.+2      	; 0x704 <DS18X20_start_meas+0x2e>

/* start measurement (CONVERT_T) for all sensors if input id==NULL
   or for single sensor. then id is the rom-code */
uint8_t DS18X20_start_meas( uint8_t with_power_extern, uint8_t id[])
{
	if( ow_reset() ) return DS18X20_ERROR;
     702:	c2 e0       	ldi	r28, 0x02	; 2
     704:	8c 2f       	mov	r24, r28
			ow_parasite_enable();
		return DS18X20_OK;
	}
	else {

		return DS18X20_START_FAIL;
     706:	df 91       	pop	r29
	}
}
     708:	cf 91       	pop	r28
     70a:	1f 91       	pop	r17
     70c:	0f 91       	pop	r16
     70e:	08 95       	ret

00000710 <DS18X20_read_meas>:
     710:	4f 92       	push	r4
     712:	5f 92       	push	r5
/* reads temperature (scratchpad) of sensor with rom-code id
   output: subzero==1 if temp.<0, cel: full celsius, mcel: frac
   in millicelsius*0.1
   i.e.: subzero=1, cel=18, millicel=5000 = -18,5000°C */
uint8_t DS18X20_read_meas(uint8_t *id, uint8_t *subzero, uint8_t *cel, uint8_t *cel_frac_bits)
{
     714:	6f 92       	push	r6
     716:	7f 92       	push	r7
     718:	8f 92       	push	r8
     71a:	9f 92       	push	r9
     71c:	af 92       	push	r10
     71e:	bf 92       	push	r11
     720:	cf 92       	push	r12
     722:	df 92       	push	r13
     724:	ef 92       	push	r14
     726:	ff 92       	push	r15
     728:	0f 93       	push	r16
     72a:	1f 93       	push	r17
     72c:	cf 93       	push	r28
     72e:	df 93       	push	r29
     730:	cd b7       	in	r28, 0x3d	; 61
     732:	de b7       	in	r29, 0x3e	; 62
     734:	29 97       	sbiw	r28, 0x09	; 9
     736:	0f b6       	in	r0, 0x3f	; 63
     738:	f8 94       	cli
     73a:	de bf       	out	0x3e, r29	; 62
     73c:	0f be       	out	0x3f, r0	; 63
     73e:	cd bf       	out	0x3d, r28	; 61
     740:	6c 01       	movw	r12, r24
     742:	3b 01       	movw	r6, r22
     744:	5a 01       	movw	r10, r20
     746:	89 01       	movw	r16, r18
	uint8_t i;
	uint8_t sp[DS18X20_SP_SIZE];

	if( ow_reset() ) return DS18X20_ERROR;
     748:	d5 d0       	rcall	.+426    	; 0x8f4 <ow_reset>
     74a:	81 11       	cpse	r24, r1
     74c:	20 c0       	rjmp	.+64     	; 0x78e <DS18X20_read_meas+0x7e>

	ow_command(DS18X20_READ, id);
     74e:	b6 01       	movw	r22, r12
     750:	8e eb       	ldi	r24, 0xBE	; 190
     752:	56 d1       	rcall	.+684    	; 0xa00 <ow_command>
     754:	ce 01       	movw	r24, r28
     756:	01 96       	adiw	r24, 0x01	; 1
     758:	7c 01       	movw	r14, r24
     75a:	4e 01       	movw	r8, r28
     75c:	9a e0       	ldi	r25, 0x0A	; 10
     75e:	89 0e       	add	r8, r25
     760:	91 1c       	adc	r9, r1
	for ( i=0 ; i< DS18X20_SP_SIZE; i++ ) sp[i]=ow_byte_rd();
     762:	27 01       	movw	r4, r14
     764:	03 d1       	rcall	.+518    	; 0x96c <ow_byte_rd>
     766:	f7 01       	movw	r30, r14
     768:	81 93       	st	Z+, r24
     76a:	7f 01       	movw	r14, r30
     76c:	e8 15       	cp	r30, r8
     76e:	f9 05       	cpc	r31, r9
     770:	c9 f7       	brne	.-14     	; 0x764 <DS18X20_read_meas+0x54>
	if ( crc8( &sp[0], DS18X20_SP_SIZE ) )
     772:	69 e0       	ldi	r22, 0x09	; 9
     774:	70 e0       	ldi	r23, 0x00	; 0
     776:	c2 01       	movw	r24, r4
     778:	e0 de       	rcall	.-576    	; 0x53a <crc8>
     77a:	f8 2e       	mov	r15, r24
     77c:	81 11       	cpse	r24, r1
     77e:	0a c0       	rjmp	.+20     	; 0x794 <DS18X20_read_meas+0x84>
		return DS18X20_ERROR_CRC;
	DS18X20_meas_to_cel(id[0], sp, subzero, cel, cel_frac_bits);
     780:	95 01       	movw	r18, r10
     782:	a3 01       	movw	r20, r6
     784:	b2 01       	movw	r22, r4
     786:	f6 01       	movw	r30, r12
     788:	80 81       	ld	r24, Z
     78a:	f0 de       	rcall	.-544    	; 0x56c <DS18X20_meas_to_cel>
	return DS18X20_OK;
     78c:	05 c0       	rjmp	.+10     	; 0x798 <DS18X20_read_meas+0x88>
uint8_t DS18X20_read_meas(uint8_t *id, uint8_t *subzero, uint8_t *cel, uint8_t *cel_frac_bits)
{
	uint8_t i;
	uint8_t sp[DS18X20_SP_SIZE];

	if( ow_reset() ) return DS18X20_ERROR;
     78e:	ff 24       	eor	r15, r15
     790:	f3 94       	inc	r15
     792:	02 c0       	rjmp	.+4      	; 0x798 <DS18X20_read_meas+0x88>

	ow_command(DS18X20_READ, id);
	for ( i=0 ; i< DS18X20_SP_SIZE; i++ ) sp[i]=ow_byte_rd();
	if ( crc8( &sp[0], DS18X20_SP_SIZE ) )
		return DS18X20_ERROR_CRC;
     794:	83 e0       	ldi	r24, 0x03	; 3
     796:	f8 2e       	mov	r15, r24
	DS18X20_meas_to_cel(id[0], sp, subzero, cel, cel_frac_bits);
	return DS18X20_OK;
}
     798:	8f 2d       	mov	r24, r15
     79a:	29 96       	adiw	r28, 0x09	; 9
     79c:	0f b6       	in	r0, 0x3f	; 63
     79e:	f8 94       	cli
     7a0:	de bf       	out	0x3e, r29	; 62
     7a2:	0f be       	out	0x3f, r0	; 63
     7a4:	cd bf       	out	0x3d, r28	; 61
     7a6:	df 91       	pop	r29
     7a8:	cf 91       	pop	r28
     7aa:	1f 91       	pop	r17
     7ac:	0f 91       	pop	r16
     7ae:	ff 90       	pop	r15
     7b0:	ef 90       	pop	r14
     7b2:	df 90       	pop	r13
     7b4:	cf 90       	pop	r12
     7b6:	bf 90       	pop	r11
     7b8:	af 90       	pop	r10
     7ba:	9f 90       	pop	r9
     7bc:	8f 90       	pop	r8
     7be:	7f 90       	pop	r7
     7c0:	6f 90       	pop	r6
     7c2:	5f 90       	pop	r5
     7c4:	4f 90       	pop	r4
     7c6:	08 95       	ret

000007c8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     7c8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     7ca:	03 96       	adiw	r24, 0x03	; 3
     7cc:	92 83       	std	Z+2, r25	; 0x02
     7ce:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     7d0:	2f ef       	ldi	r18, 0xFF	; 255
     7d2:	3f ef       	ldi	r19, 0xFF	; 255
     7d4:	34 83       	std	Z+4, r19	; 0x04
     7d6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     7d8:	96 83       	std	Z+6, r25	; 0x06
     7da:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     7dc:	90 87       	std	Z+8, r25	; 0x08
     7de:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     7e0:	10 82       	st	Z, r1
     7e2:	08 95       	ret

000007e4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     7e4:	fc 01       	movw	r30, r24
     7e6:	11 86       	std	Z+9, r1	; 0x09
     7e8:	10 86       	std	Z+8, r1	; 0x08
     7ea:	08 95       	ret

000007ec <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     7ec:	cf 93       	push	r28
     7ee:	df 93       	push	r29
     7f0:	dc 01       	movw	r26, r24
     7f2:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     7f4:	11 96       	adiw	r26, 0x01	; 1
     7f6:	2d 91       	ld	r18, X+
     7f8:	3c 91       	ld	r19, X
     7fa:	12 97       	sbiw	r26, 0x02	; 2

	pxNewListItem->pxNext = pxIndex->pxNext;
     7fc:	e9 01       	movw	r28, r18
     7fe:	8a 81       	ldd	r24, Y+2	; 0x02
     800:	9b 81       	ldd	r25, Y+3	; 0x03
     802:	93 83       	std	Z+3, r25	; 0x03
     804:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     806:	35 83       	std	Z+5, r19	; 0x05
     808:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     80a:	8a 81       	ldd	r24, Y+2	; 0x02
     80c:	9b 81       	ldd	r25, Y+3	; 0x03
     80e:	ec 01       	movw	r28, r24
     810:	7d 83       	std	Y+5, r23	; 0x05
     812:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     814:	e9 01       	movw	r28, r18
     816:	7b 83       	std	Y+3, r23	; 0x03
     818:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     81a:	12 96       	adiw	r26, 0x02	; 2
     81c:	7c 93       	st	X, r23
     81e:	6e 93       	st	-X, r22
     820:	11 97       	sbiw	r26, 0x01	; 1

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     822:	b1 87       	std	Z+9, r27	; 0x09
     824:	a0 87       	std	Z+8, r26	; 0x08

	( pxList->uxNumberOfItems )++;
     826:	8c 91       	ld	r24, X
     828:	8f 5f       	subi	r24, 0xFF	; 255
     82a:	8c 93       	st	X, r24
}
     82c:	df 91       	pop	r29
     82e:	cf 91       	pop	r28
     830:	08 95       	ret

00000832 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     832:	cf 93       	push	r28
     834:	df 93       	push	r29
     836:	ac 01       	movw	r20, r24
     838:	db 01       	movw	r26, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     83a:	8d 91       	ld	r24, X+
     83c:	9c 91       	ld	r25, X
     83e:	11 97       	sbiw	r26, 0x01	; 1
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     840:	8f 3f       	cpi	r24, 0xFF	; 255
     842:	2f ef       	ldi	r18, 0xFF	; 255
     844:	92 07       	cpc	r25, r18
     846:	21 f4       	brne	.+8      	; 0x850 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     848:	ea 01       	movw	r28, r20
     84a:	ef 81       	ldd	r30, Y+7	; 0x07
     84c:	f8 85       	ldd	r31, Y+8	; 0x08
     84e:	0e c0       	rjmp	.+28     	; 0x86c <__stack+0xd>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     850:	fa 01       	movw	r30, r20
     852:	33 96       	adiw	r30, 0x03	; 3
     854:	22 81       	ldd	r18, Z+2	; 0x02
     856:	33 81       	ldd	r19, Z+3	; 0x03
     858:	e9 01       	movw	r28, r18
     85a:	28 81       	ld	r18, Y
     85c:	39 81       	ldd	r19, Y+1	; 0x01
     85e:	82 17       	cp	r24, r18
     860:	93 07       	cpc	r25, r19
     862:	20 f0       	brcs	.+8      	; 0x86c <__stack+0xd>
     864:	02 80       	ldd	r0, Z+2	; 0x02
     866:	f3 81       	ldd	r31, Z+3	; 0x03
     868:	e0 2d       	mov	r30, r0
     86a:	f4 cf       	rjmp	.-24     	; 0x854 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     86c:	82 81       	ldd	r24, Z+2	; 0x02
     86e:	93 81       	ldd	r25, Z+3	; 0x03
     870:	13 96       	adiw	r26, 0x03	; 3
     872:	9c 93       	st	X, r25
     874:	8e 93       	st	-X, r24
     876:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     878:	ec 01       	movw	r28, r24
     87a:	bd 83       	std	Y+5, r27	; 0x05
     87c:	ac 83       	std	Y+4, r26	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     87e:	15 96       	adiw	r26, 0x05	; 5
     880:	fc 93       	st	X, r31
     882:	ee 93       	st	-X, r30
     884:	14 97       	sbiw	r26, 0x04	; 4
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     886:	b3 83       	std	Z+3, r27	; 0x03
     888:	a2 83       	std	Z+2, r26	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     88a:	19 96       	adiw	r26, 0x09	; 9
     88c:	5c 93       	st	X, r21
     88e:	4e 93       	st	-X, r20
     890:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     892:	fa 01       	movw	r30, r20
     894:	80 81       	ld	r24, Z
     896:	8f 5f       	subi	r24, 0xFF	; 255
     898:	80 83       	st	Z, r24
}
     89a:	df 91       	pop	r29
     89c:	cf 91       	pop	r28
     89e:	08 95       	ret

000008a0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     8a0:	cf 93       	push	r28
     8a2:	df 93       	push	r29
     8a4:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     8a6:	a2 81       	ldd	r26, Z+2	; 0x02
     8a8:	b3 81       	ldd	r27, Z+3	; 0x03
     8aa:	84 81       	ldd	r24, Z+4	; 0x04
     8ac:	95 81       	ldd	r25, Z+5	; 0x05
     8ae:	15 96       	adiw	r26, 0x05	; 5
     8b0:	9c 93       	st	X, r25
     8b2:	8e 93       	st	-X, r24
     8b4:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     8b6:	c4 81       	ldd	r28, Z+4	; 0x04
     8b8:	d5 81       	ldd	r29, Z+5	; 0x05
     8ba:	bb 83       	std	Y+3, r27	; 0x03
     8bc:	aa 83       	std	Y+2, r26	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     8be:	a0 85       	ldd	r26, Z+8	; 0x08
     8c0:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     8c2:	11 96       	adiw	r26, 0x01	; 1
     8c4:	8d 91       	ld	r24, X+
     8c6:	9c 91       	ld	r25, X
     8c8:	12 97       	sbiw	r26, 0x02	; 2
     8ca:	e8 17       	cp	r30, r24
     8cc:	f9 07       	cpc	r31, r25
     8ce:	21 f4       	brne	.+8      	; 0x8d8 <vListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     8d0:	12 96       	adiw	r26, 0x02	; 2
     8d2:	dc 93       	st	X, r29
     8d4:	ce 93       	st	-X, r28
     8d6:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     8d8:	11 86       	std	Z+9, r1	; 0x09
     8da:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     8dc:	8c 91       	ld	r24, X
     8de:	81 50       	subi	r24, 0x01	; 1
     8e0:	8c 93       	st	X, r24
}
     8e2:	df 91       	pop	r29
     8e4:	cf 91       	pop	r28
     8e6:	08 95       	ret

000008e8 <ow_input_pin_state>:
}

void ow_parasite_disable(void)
{
    OW_OUT_LOW();
	OW_DIR_IN();
     8e8:	80 b3       	in	r24, 0x10	; 16
     8ea:	80 72       	andi	r24, 0x20	; 32
     8ec:	08 95       	ret

000008ee <ow_parasite_enable>:
     8ee:	95 9a       	sbi	0x12, 5	; 18
     8f0:	8d 9a       	sbi	0x11, 5	; 17
     8f2:	08 95       	ret

000008f4 <ow_reset>:
uint8_t ow_reset(void)
{
	uint8_t err;
	uint8_t sreg;

	OW_OUT_LOW(); // disable internal pull-up (maybe on from parasite)
     8f4:	95 98       	cbi	0x12, 5	; 18
	OW_DIR_OUT(); // pull OW-Pin low for 480us
     8f6:	8d 9a       	sbi	0x11, 5	; 17
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     8f8:	80 e8       	ldi	r24, 0x80	; 128
     8fa:	97 e0       	ldi	r25, 0x07	; 7
     8fc:	01 97       	sbiw	r24, 0x01	; 1
     8fe:	f1 f7       	brne	.-4      	; 0x8fc <ow_reset+0x8>

	_delay_us(480);

	sreg=SREG;
     900:	2f b7       	in	r18, 0x3f	; 63
	cli();
     902:	f8 94       	cli

	// set Pin as input - wait for clients to pull low
	OW_DIR_IN(); // input
     904:	8d 98       	cbi	0x11, 5	; 17
     906:	88 e0       	ldi	r24, 0x08	; 8
     908:	91 e0       	ldi	r25, 0x01	; 1
     90a:	01 97       	sbiw	r24, 0x01	; 1
     90c:	f1 f7       	brne	.-4      	; 0x90a <ow_reset+0x16>

	_delay_us(66);
	err = OW_GET_IN();		// no presence detect
     90e:	80 b3       	in	r24, 0x10	; 16
	// nobody pulled to low, still high

	SREG=sreg; // sei()
     910:	2f bf       	out	0x3f, r18	; 63
     912:	e8 e7       	ldi	r30, 0x78	; 120
     914:	f6 e0       	ldi	r31, 0x06	; 6
     916:	31 97       	sbiw	r30, 0x01	; 1
     918:	f1 f7       	brne	.-4      	; 0x916 <ow_reset+0x22>

	// after a delay the clients should release the line
	// and input-pin gets back to high due to pull-up-resistor
	_delay_us(480-66);
	if( OW_GET_IN() == 0 )		// short circuit
     91a:	85 9b       	sbis	0x10, 5	; 16
     91c:	02 c0       	rjmp	.+4      	; 0x922 <ow_reset+0x2e>

	// set Pin as input - wait for clients to pull low
	OW_DIR_IN(); // input

	_delay_us(66);
	err = OW_GET_IN();		// no presence detect
     91e:	80 72       	andi	r24, 0x20	; 32
     920:	08 95       	ret

	// after a delay the clients should release the line
	// and input-pin gets back to high due to pull-up-resistor
	_delay_us(480-66);
	if( OW_GET_IN() == 0 )		// short circuit
		err = 1;
     922:	81 e0       	ldi	r24, 0x01	; 1

	return err;
}
     924:	08 95       	ret

00000926 <ow_bit_io>:
   but around 14 cyles in configureable bus (us-Delay is 4 cyles per uS) */
uint8_t ow_bit_io( uint8_t b )
{
	uint8_t sreg;

	sreg=SREG;
     926:	2f b7       	in	r18, 0x3f	; 63
	cli();
     928:	f8 94       	cli

	OW_DIR_OUT(); // drive bus low
     92a:	8d 9a       	sbi	0x11, 5	; 17
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     92c:	95 e0       	ldi	r25, 0x05	; 5
     92e:	9a 95       	dec	r25
     930:	f1 f7       	brne	.-4      	; 0x92e <ow_bit_io+0x8>

	_delay_us(1); // Recovery-Time wuffwuff was 1
	if ( b ) OW_DIR_IN(); // if bit is 1 set bus high (by ext. pull-up)
     932:	81 11       	cpse	r24, r1
     934:	8d 98       	cbi	0x11, 5	; 17
     936:	90 e5       	ldi	r25, 0x50	; 80
     938:	9a 95       	dec	r25
     93a:	f1 f7       	brne	.-4      	; 0x938 <ow_bit_io+0x12>

	_delay_us(15);

	if( OW_GET_IN() == 0 ) b = 0;  // sample at end of read-timeslot
     93c:	85 9b       	sbis	0x10, 5	; 16
     93e:	80 e0       	ldi	r24, 0x00	; 0
     940:	90 ef       	ldi	r25, 0xF0	; 240
     942:	9a 95       	dec	r25
     944:	f1 f7       	brne	.-4      	; 0x942 <ow_bit_io+0x1c>

	_delay_us(60-15);
	OW_DIR_IN();
     946:	8d 98       	cbi	0x11, 5	; 17

	SREG=sreg; // sei();
     948:	2f bf       	out	0x3f, r18	; 63

	return b;
}
     94a:	08 95       	ret

0000094c <ow_byte_wr>:


uint8_t ow_byte_wr( uint8_t b )
{
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	c8 2f       	mov	r28, r24
     952:	d8 e0       	ldi	r29, 0x08	; 8
	uint8_t i = 8, j;

	do {
		j = ow_bit_io( b & 1 );
     954:	8c 2f       	mov	r24, r28
     956:	81 70       	andi	r24, 0x01	; 1
     958:	e6 df       	rcall	.-52     	; 0x926 <ow_bit_io>
		b >>= 1;
     95a:	c6 95       	lsr	r28
		if( j ) b |= 0x80;
     95c:	81 11       	cpse	r24, r1
     95e:	c0 68       	ori	r28, 0x80	; 128
     960:	d1 50       	subi	r29, 0x01	; 1
	} while( --i );
     962:	c1 f7       	brne	.-16     	; 0x954 <ow_byte_wr+0x8>

	return b;
}
     964:	8c 2f       	mov	r24, r28
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	08 95       	ret

0000096c <ow_byte_rd>:


uint8_t ow_byte_rd( void )
{
  // read by sending 0xff (a dontcare?)
  return ow_byte_wr( 0xFF );
     96c:	8f ef       	ldi	r24, 0xFF	; 255
     96e:	ee cf       	rjmp	.-36     	; 0x94c <ow_byte_wr>

00000970 <ow_rom_search>:
}


uint8_t ow_rom_search( uint8_t diff, uint8_t *id )
{
     970:	df 92       	push	r13
     972:	ef 92       	push	r14
     974:	ff 92       	push	r15
     976:	0f 93       	push	r16
     978:	1f 93       	push	r17
     97a:	cf 93       	push	r28
     97c:	df 93       	push	r29
     97e:	e8 2e       	mov	r14, r24
     980:	8b 01       	movw	r16, r22
	uint8_t i, j, next_diff;
	uint8_t b;

	if( ow_reset() ) return OW_PRESENCE_ERR;	// error, no device found
     982:	b8 df       	rcall	.-144    	; 0x8f4 <ow_reset>
     984:	81 11       	cpse	r24, r1
     986:	31 c0       	rjmp	.+98     	; 0x9ea <ow_rom_search+0x7a>

	ow_byte_wr( OW_SEARCH_ROM );			// ROM search command
     988:	80 ef       	ldi	r24, 0xF0	; 240
     98a:	e0 df       	rcall	.-64     	; 0x94c <ow_byte_wr>
	next_diff = OW_LAST_DEVICE;			// unchanged on last device
     98c:	d0 e0       	ldi	r29, 0x00	; 0

	i = OW_ROMCODE_SIZE * 8;					// 8 bytes
     98e:	c0 e4       	ldi	r28, 0x40	; 64
     990:	88 ef       	ldi	r24, 0xF8	; 248
     992:	d8 2e       	mov	r13, r24

	do {
		j = 8;					// 8 bits
		do {
			b = ow_bit_io( 1 );			// read bit
     994:	dc 0e       	add	r13, r28
     996:	81 e0       	ldi	r24, 0x01	; 1
     998:	c6 df       	rcall	.-116    	; 0x926 <ow_bit_io>
			if( ow_bit_io( 1 ) ) {			// read complement bit
     99a:	f8 2e       	mov	r15, r24
     99c:	81 e0       	ldi	r24, 0x01	; 1
     99e:	c3 df       	rcall	.-122    	; 0x926 <ow_bit_io>
     9a0:	88 23       	and	r24, r24
     9a2:	19 f0       	breq	.+6      	; 0x9aa <ow_rom_search+0x3a>
				if( b )					// 11
     9a4:	ff 20       	and	r15, r15
     9a6:	71 f0       	breq	.+28     	; 0x9c4 <ow_rom_search+0x54>
     9a8:	22 c0       	rjmp	.+68     	; 0x9ee <ow_rom_search+0x7e>
				return OW_DATA_ERR;			// data error
			}
			else {
				if( !b ) {				// 00 = 2 devices
     9aa:	f1 10       	cpse	r15, r1
     9ac:	0b c0       	rjmp	.+22     	; 0x9c4 <ow_rom_search+0x54>
					if( diff > i || ((*id & 1) && diff != i) ) {
     9ae:	ce 15       	cp	r28, r14
     9b0:	30 f0       	brcs	.+12     	; 0x9be <ow_rom_search+0x4e>
     9b2:	f8 01       	movw	r30, r16
     9b4:	80 81       	ld	r24, Z
     9b6:	80 ff       	sbrs	r24, 0
     9b8:	05 c0       	rjmp	.+10     	; 0x9c4 <ow_rom_search+0x54>
     9ba:	ce 15       	cp	r28, r14
     9bc:	19 f0       	breq	.+6      	; 0x9c4 <ow_rom_search+0x54>
					b = 1;				// now 1
     9be:	dc 2f       	mov	r29, r28
     9c0:	ff 24       	eor	r15, r15
					next_diff = i;			// next pass 0
					}
				}
			}
			ow_bit_io( b );     			// write bit
     9c2:	f3 94       	inc	r15
     9c4:	8f 2d       	mov	r24, r15
     9c6:	af df       	rcall	.-162    	; 0x926 <ow_bit_io>
			*id >>= 1;
     9c8:	f8 01       	movw	r30, r16
     9ca:	80 81       	ld	r24, Z
     9cc:	86 95       	lsr	r24
			if( b ) *id |= 0x80;			// store bit
     9ce:	ff 20       	and	r15, r15
     9d0:	11 f0       	breq	.+4      	; 0x9d6 <ow_rom_search+0x66>
     9d2:	80 68       	ori	r24, 0x80	; 128
     9d4:	f8 01       	movw	r30, r16
     9d6:	80 83       	st	Z, r24

			i--;
     9d8:	c1 50       	subi	r28, 0x01	; 1

		} while( --j );
     9da:	cd 11       	cpse	r28, r13
     9dc:	dc cf       	rjmp	.-72     	; 0x996 <ow_rom_search+0x26>

		id++;					// next byte
     9de:	0f 5f       	subi	r16, 0xFF	; 255
     9e0:	1f 4f       	sbci	r17, 0xFF	; 255

	} while( i );
     9e2:	c1 11       	cpse	r28, r1
     9e4:	d5 cf       	rjmp	.-86     	; 0x990 <ow_rom_search+0x20>
     9e6:	8d 2f       	mov	r24, r29
     9e8:	03 c0       	rjmp	.+6      	; 0x9f0 <ow_rom_search+0x80>
uint8_t ow_rom_search( uint8_t diff, uint8_t *id )
{
	uint8_t i, j, next_diff;
	uint8_t b;

	if( ow_reset() ) return OW_PRESENCE_ERR;	// error, no device found
     9ea:	8f ef       	ldi	r24, 0xFF	; 255
     9ec:	01 c0       	rjmp	.+2      	; 0x9f0 <ow_rom_search+0x80>
		j = 8;					// 8 bits
		do {
			b = ow_bit_io( 1 );			// read bit
			if( ow_bit_io( 1 ) ) {			// read complement bit
				if( b )					// 11
				return OW_DATA_ERR;			// data error
     9ee:	8e ef       	ldi	r24, 0xFE	; 254
		id++;					// next byte

	} while( i );

	return next_diff;				// to continue search
}
     9f0:	df 91       	pop	r29
     9f2:	cf 91       	pop	r28
     9f4:	1f 91       	pop	r17
     9f6:	0f 91       	pop	r16
     9f8:	ff 90       	pop	r15
     9fa:	ef 90       	pop	r14
     9fc:	df 90       	pop	r13
     9fe:	08 95       	ret

00000a00 <ow_command>:


void ow_command( uint8_t command, uint8_t *id )
{
     a00:	ef 92       	push	r14
     a02:	ff 92       	push	r15
     a04:	1f 93       	push	r17
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
     a0a:	18 2f       	mov	r17, r24
     a0c:	eb 01       	movw	r28, r22
	uint8_t i;

	ow_reset();
     a0e:	72 df       	rcall	.-284    	; 0x8f4 <ow_reset>

	if( id ) {
     a10:	20 97       	sbiw	r28, 0x00	; 0
     a12:	61 f0       	breq	.+24     	; 0xa2c <ow_command+0x2c>
		ow_byte_wr( OW_MATCH_ROM );			// to a single device
     a14:	85 e5       	ldi	r24, 0x55	; 85
     a16:	9a df       	rcall	.-204    	; 0x94c <ow_byte_wr>
     a18:	7e 01       	movw	r14, r28
     a1a:	88 e0       	ldi	r24, 0x08	; 8
     a1c:	e8 0e       	add	r14, r24
     a1e:	f1 1c       	adc	r15, r1
		i = OW_ROMCODE_SIZE;
		do {
			ow_byte_wr( *id );
     a20:	89 91       	ld	r24, Y+
     a22:	94 df       	rcall	.-216    	; 0x94c <ow_byte_wr>
     a24:	ce 15       	cp	r28, r14
			id++;
		} while( --i );
     a26:	df 05       	cpc	r29, r15
     a28:	d9 f7       	brne	.-10     	; 0xa20 <ow_command+0x20>
     a2a:	02 c0       	rjmp	.+4      	; 0xa30 <ow_command+0x30>
	}
	else {
		ow_byte_wr( OW_SKIP_ROM );			// to all devices
     a2c:	8c ec       	ldi	r24, 0xCC	; 204
     a2e:	8e df       	rcall	.-228    	; 0x94c <ow_byte_wr>
     a30:	81 2f       	mov	r24, r17
	}

	ow_byte_wr( command );
     a32:	df 91       	pop	r29
}
     a34:	cf 91       	pop	r28
     a36:	1f 91       	pop	r17
     a38:	ff 90       	pop	r15
     a3a:	ef 90       	pop	r14
	}
	else {
		ow_byte_wr( OW_SKIP_ROM );			// to all devices
	}

	ow_byte_wr( command );
     a3c:	87 cf       	rjmp	.-242    	; 0x94c <ow_byte_wr>

00000a3e <pvPortMalloc>:
     a3e:	0f 93       	push	r16

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     a40:	1f 93       	push	r17
     a42:	cf 93       	push	r28
     a44:	df 93       	push	r29
     a46:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     a48:	9e d4       	rcall	.+2364   	; 0x1386 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     a4a:	c0 91 9f 00 	lds	r28, 0x009F	; 0x80009f <xNextFreeByte>
     a4e:	d0 91 a0 00 	lds	r29, 0x00A0	; 0x8000a0 <xNextFreeByte+0x1>
     a52:	ce 01       	movw	r24, r28
     a54:	80 0f       	add	r24, r16
     a56:	91 1f       	adc	r25, r17
     a58:	8c 3d       	cpi	r24, 0xDC	; 220
     a5a:	25 e0       	ldi	r18, 0x05	; 5
     a5c:	92 07       	cpc	r25, r18
     a5e:	50 f4       	brcc	.+20     	; 0xa74 <pvPortMalloc+0x36>
     a60:	c8 17       	cp	r28, r24
     a62:	d9 07       	cpc	r29, r25
     a64:	38 f4       	brcc	.+14     	; 0xa74 <pvPortMalloc+0x36>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     a66:	cf 55       	subi	r28, 0x5F	; 95
     a68:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     a6a:	90 93 a0 00 	sts	0x00A0, r25	; 0x8000a0 <xNextFreeByte+0x1>
     a6e:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <xNextFreeByte>
     a72:	02 c0       	rjmp	.+4      	; 0xa78 <pvPortMalloc+0x3a>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     a74:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     a76:	d0 e0       	ldi	r29, 0x00	; 0
     a78:	28 d5       	rcall	.+2640   	; 0x14ca <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     a7a:	ce 01       	movw	r24, r28
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	1f 91       	pop	r17
     a82:	0f 91       	pop	r16
     a84:	08 95       	ret

00000a86 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     a86:	08 95       	ret

00000a88 <pxPortInitialiseStack>:
	portSAVE_CONTEXT();
	vTaskIncrementTick();
	vTaskSwitchContext();
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     a88:	31 e1       	ldi	r19, 0x11	; 17
     a8a:	fc 01       	movw	r30, r24
     a8c:	30 83       	st	Z, r19
     a8e:	31 97       	sbiw	r30, 0x01	; 1
     a90:	22 e2       	ldi	r18, 0x22	; 34
     a92:	20 83       	st	Z, r18
     a94:	31 97       	sbiw	r30, 0x01	; 1
     a96:	a3 e3       	ldi	r26, 0x33	; 51
     a98:	a0 83       	st	Z, r26
     a9a:	31 97       	sbiw	r30, 0x01	; 1
     a9c:	60 83       	st	Z, r22
     a9e:	31 97       	sbiw	r30, 0x01	; 1
     aa0:	70 83       	st	Z, r23
     aa2:	31 97       	sbiw	r30, 0x01	; 1
     aa4:	10 82       	st	Z, r1
     aa6:	31 97       	sbiw	r30, 0x01	; 1
     aa8:	60 e8       	ldi	r22, 0x80	; 128
     aaa:	60 83       	st	Z, r22
     aac:	31 97       	sbiw	r30, 0x01	; 1
     aae:	10 82       	st	Z, r1
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	62 e0       	ldi	r22, 0x02	; 2
     ab4:	60 83       	st	Z, r22
     ab6:	31 97       	sbiw	r30, 0x01	; 1
     ab8:	63 e0       	ldi	r22, 0x03	; 3
     aba:	60 83       	st	Z, r22
     abc:	31 97       	sbiw	r30, 0x01	; 1
     abe:	64 e0       	ldi	r22, 0x04	; 4
     ac0:	60 83       	st	Z, r22
     ac2:	31 97       	sbiw	r30, 0x01	; 1
     ac4:	65 e0       	ldi	r22, 0x05	; 5
     ac6:	60 83       	st	Z, r22
     ac8:	31 97       	sbiw	r30, 0x01	; 1
     aca:	66 e0       	ldi	r22, 0x06	; 6
     acc:	60 83       	st	Z, r22
     ace:	31 97       	sbiw	r30, 0x01	; 1
     ad0:	67 e0       	ldi	r22, 0x07	; 7
     ad2:	60 83       	st	Z, r22
     ad4:	31 97       	sbiw	r30, 0x01	; 1
     ad6:	68 e0       	ldi	r22, 0x08	; 8
     ad8:	60 83       	st	Z, r22
     ada:	31 97       	sbiw	r30, 0x01	; 1
     adc:	69 e0       	ldi	r22, 0x09	; 9
     ade:	60 83       	st	Z, r22
     ae0:	31 97       	sbiw	r30, 0x01	; 1
     ae2:	60 e1       	ldi	r22, 0x10	; 16
     ae4:	60 83       	st	Z, r22
     ae6:	31 97       	sbiw	r30, 0x01	; 1
     ae8:	30 83       	st	Z, r19
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	32 e1       	ldi	r19, 0x12	; 18
     aee:	30 83       	st	Z, r19
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	33 e1       	ldi	r19, 0x13	; 19
     af4:	30 83       	st	Z, r19
     af6:	31 97       	sbiw	r30, 0x01	; 1
     af8:	34 e1       	ldi	r19, 0x14	; 20
     afa:	30 83       	st	Z, r19
     afc:	31 97       	sbiw	r30, 0x01	; 1
     afe:	35 e1       	ldi	r19, 0x15	; 21
     b00:	30 83       	st	Z, r19
     b02:	31 97       	sbiw	r30, 0x01	; 1
     b04:	36 e1       	ldi	r19, 0x16	; 22
     b06:	30 83       	st	Z, r19
     b08:	31 97       	sbiw	r30, 0x01	; 1
     b0a:	37 e1       	ldi	r19, 0x17	; 23
     b0c:	30 83       	st	Z, r19
     b0e:	31 97       	sbiw	r30, 0x01	; 1
     b10:	38 e1       	ldi	r19, 0x18	; 24
     b12:	30 83       	st	Z, r19
     b14:	31 97       	sbiw	r30, 0x01	; 1
     b16:	39 e1       	ldi	r19, 0x19	; 25
     b18:	30 83       	st	Z, r19
     b1a:	31 97       	sbiw	r30, 0x01	; 1
     b1c:	30 e2       	ldi	r19, 0x20	; 32
     b1e:	30 83       	st	Z, r19
     b20:	31 97       	sbiw	r30, 0x01	; 1
     b22:	31 e2       	ldi	r19, 0x21	; 33
     b24:	30 83       	st	Z, r19
     b26:	31 97       	sbiw	r30, 0x01	; 1
     b28:	20 83       	st	Z, r18
     b2a:	31 97       	sbiw	r30, 0x01	; 1
     b2c:	23 e2       	ldi	r18, 0x23	; 35
     b2e:	20 83       	st	Z, r18
     b30:	31 97       	sbiw	r30, 0x01	; 1
     b32:	40 83       	st	Z, r20
     b34:	31 97       	sbiw	r30, 0x01	; 1
     b36:	50 83       	st	Z, r21
     b38:	31 97       	sbiw	r30, 0x01	; 1
     b3a:	26 e2       	ldi	r18, 0x26	; 38
     b3c:	20 83       	st	Z, r18
     b3e:	31 97       	sbiw	r30, 0x01	; 1
     b40:	27 e2       	ldi	r18, 0x27	; 39
     b42:	20 83       	st	Z, r18
     b44:	31 97       	sbiw	r30, 0x01	; 1
     b46:	28 e2       	ldi	r18, 0x28	; 40
     b48:	20 83       	st	Z, r18
     b4a:	31 97       	sbiw	r30, 0x01	; 1
     b4c:	29 e2       	ldi	r18, 0x29	; 41
     b4e:	20 83       	st	Z, r18
     b50:	31 97       	sbiw	r30, 0x01	; 1
     b52:	20 e3       	ldi	r18, 0x30	; 48
     b54:	20 83       	st	Z, r18
     b56:	31 97       	sbiw	r30, 0x01	; 1
     b58:	21 e3       	ldi	r18, 0x31	; 49
     b5a:	20 83       	st	Z, r18
     b5c:	86 97       	sbiw	r24, 0x26	; 38
     b5e:	08 95       	ret

00000b60 <xPortStartScheduler>:
     b60:	1b bc       	out	0x2b, r1	; 43
     b62:	89 ef       	ldi	r24, 0xF9	; 249
     b64:	8a bd       	out	0x2a, r24	; 42
     b66:	8b e0       	ldi	r24, 0x0B	; 11
     b68:	8e bd       	out	0x2e, r24	; 46
     b6a:	89 b7       	in	r24, 0x39	; 57
     b6c:	80 61       	ori	r24, 0x10	; 16
     b6e:	89 bf       	out	0x39, r24	; 57
     b70:	a0 91 cb 06 	lds	r26, 0x06CB	; 0x8006cb <pxCurrentTCB>
     b74:	b0 91 cc 06 	lds	r27, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
     b78:	cd 91       	ld	r28, X+
     b7a:	cd bf       	out	0x3d, r28	; 61
     b7c:	dd 91       	ld	r29, X+
     b7e:	de bf       	out	0x3e, r29	; 62
     b80:	ff 91       	pop	r31
     b82:	ef 91       	pop	r30
     b84:	df 91       	pop	r29
     b86:	cf 91       	pop	r28
     b88:	bf 91       	pop	r27
     b8a:	af 91       	pop	r26
     b8c:	9f 91       	pop	r25
     b8e:	8f 91       	pop	r24
     b90:	7f 91       	pop	r23
     b92:	6f 91       	pop	r22
     b94:	5f 91       	pop	r21
     b96:	4f 91       	pop	r20
     b98:	3f 91       	pop	r19
     b9a:	2f 91       	pop	r18
     b9c:	1f 91       	pop	r17
     b9e:	0f 91       	pop	r16
     ba0:	ff 90       	pop	r15
     ba2:	ef 90       	pop	r14
     ba4:	df 90       	pop	r13
     ba6:	cf 90       	pop	r12
     ba8:	bf 90       	pop	r11
     baa:	af 90       	pop	r10
     bac:	9f 90       	pop	r9
     bae:	8f 90       	pop	r8
     bb0:	7f 90       	pop	r7
     bb2:	6f 90       	pop	r6
     bb4:	5f 90       	pop	r5
     bb6:	4f 90       	pop	r4
     bb8:	3f 90       	pop	r3
     bba:	2f 90       	pop	r2
     bbc:	1f 90       	pop	r1
     bbe:	0f 90       	pop	r0
     bc0:	0f be       	out	0x3f, r0	; 63
     bc2:	0f 90       	pop	r0
     bc4:	08 95       	ret
     bc6:	81 e0       	ldi	r24, 0x01	; 1
     bc8:	08 95       	ret

00000bca <vPortYield>:
     bca:	0f 92       	push	r0
     bcc:	0f b6       	in	r0, 0x3f	; 63
     bce:	f8 94       	cli
     bd0:	0f 92       	push	r0
     bd2:	1f 92       	push	r1
     bd4:	11 24       	eor	r1, r1
     bd6:	2f 92       	push	r2
     bd8:	3f 92       	push	r3
     bda:	4f 92       	push	r4
     bdc:	5f 92       	push	r5
     bde:	6f 92       	push	r6
     be0:	7f 92       	push	r7
     be2:	8f 92       	push	r8
     be4:	9f 92       	push	r9
     be6:	af 92       	push	r10
     be8:	bf 92       	push	r11
     bea:	cf 92       	push	r12
     bec:	df 92       	push	r13
     bee:	ef 92       	push	r14
     bf0:	ff 92       	push	r15
     bf2:	0f 93       	push	r16
     bf4:	1f 93       	push	r17
     bf6:	2f 93       	push	r18
     bf8:	3f 93       	push	r19
     bfa:	4f 93       	push	r20
     bfc:	5f 93       	push	r21
     bfe:	6f 93       	push	r22
     c00:	7f 93       	push	r23
     c02:	8f 93       	push	r24
     c04:	9f 93       	push	r25
     c06:	af 93       	push	r26
     c08:	bf 93       	push	r27
     c0a:	cf 93       	push	r28
     c0c:	df 93       	push	r29
     c0e:	ef 93       	push	r30
     c10:	ff 93       	push	r31
     c12:	a0 91 cb 06 	lds	r26, 0x06CB	; 0x8006cb <pxCurrentTCB>
     c16:	b0 91 cc 06 	lds	r27, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
     c1a:	0d b6       	in	r0, 0x3d	; 61
     c1c:	0d 92       	st	X+, r0
     c1e:	0e b6       	in	r0, 0x3e	; 62
     c20:	0d 92       	st	X+, r0
     c22:	d8 d4       	rcall	.+2480   	; 0x15d4 <vTaskSwitchContext>
     c24:	a0 91 cb 06 	lds	r26, 0x06CB	; 0x8006cb <pxCurrentTCB>
     c28:	b0 91 cc 06 	lds	r27, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
     c2c:	cd 91       	ld	r28, X+
     c2e:	cd bf       	out	0x3d, r28	; 61
     c30:	dd 91       	ld	r29, X+
     c32:	de bf       	out	0x3e, r29	; 62
     c34:	ff 91       	pop	r31
     c36:	ef 91       	pop	r30
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	bf 91       	pop	r27
     c3e:	af 91       	pop	r26
     c40:	9f 91       	pop	r25
     c42:	8f 91       	pop	r24
     c44:	7f 91       	pop	r23
     c46:	6f 91       	pop	r22
     c48:	5f 91       	pop	r21
     c4a:	4f 91       	pop	r20
     c4c:	3f 91       	pop	r19
     c4e:	2f 91       	pop	r18
     c50:	1f 91       	pop	r17
     c52:	0f 91       	pop	r16
     c54:	ff 90       	pop	r15
     c56:	ef 90       	pop	r14
     c58:	df 90       	pop	r13
     c5a:	cf 90       	pop	r12
     c5c:	bf 90       	pop	r11
     c5e:	af 90       	pop	r10
     c60:	9f 90       	pop	r9
     c62:	8f 90       	pop	r8
     c64:	7f 90       	pop	r7
     c66:	6f 90       	pop	r6
     c68:	5f 90       	pop	r5
     c6a:	4f 90       	pop	r4
     c6c:	3f 90       	pop	r3
     c6e:	2f 90       	pop	r2
     c70:	1f 90       	pop	r1
     c72:	0f 90       	pop	r0
     c74:	0f be       	out	0x3f, r0	; 63
     c76:	0f 90       	pop	r0
     c78:	08 95       	ret

00000c7a <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
     c7a:	1f 92       	push	r1
     c7c:	0f 92       	push	r0
     c7e:	0f b6       	in	r0, 0x3f	; 63
     c80:	0f 92       	push	r0
     c82:	11 24       	eor	r1, r1
     c84:	2f 93       	push	r18
     c86:	3f 93       	push	r19
     c88:	4f 93       	push	r20
     c8a:	5f 93       	push	r21
     c8c:	6f 93       	push	r22
     c8e:	7f 93       	push	r23
     c90:	8f 93       	push	r24
     c92:	9f 93       	push	r25
     c94:	af 93       	push	r26
     c96:	bf 93       	push	r27
     c98:	ef 93       	push	r30
     c9a:	ff 93       	push	r31
		vTaskIncrementTick();
     c9c:	7a d3       	rcall	.+1780   	; 0x1392 <vTaskIncrementTick>
	}
     c9e:	ff 91       	pop	r31
     ca0:	ef 91       	pop	r30
     ca2:	bf 91       	pop	r27
     ca4:	af 91       	pop	r26
     ca6:	9f 91       	pop	r25
     ca8:	8f 91       	pop	r24
     caa:	7f 91       	pop	r23
     cac:	6f 91       	pop	r22
     cae:	5f 91       	pop	r21
     cb0:	4f 91       	pop	r20
     cb2:	3f 91       	pop	r19
     cb4:	2f 91       	pop	r18
     cb6:	0f 90       	pop	r0
     cb8:	0f be       	out	0x3f, r0	; 63
     cba:	0f 90       	pop	r0
     cbc:	1f 90       	pop	r1
     cbe:	18 95       	reti

00000cc0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     cc0:	cf 93       	push	r28
     cc2:	df 93       	push	r29
     cc4:	ec 01       	movw	r28, r24
     cc6:	94 2f       	mov	r25, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     cc8:	8c 8d       	ldd	r24, Y+28	; 0x1c
     cca:	88 23       	and	r24, r24
     ccc:	89 f1       	breq	.+98     	; 0xd30 <prvCopyDataToQueue+0x70>
     cce:	48 2f       	mov	r20, r24
     cd0:	50 e0       	ldi	r21, 0x00	; 0
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     cd2:	91 11       	cpse	r25, r1
     cd4:	14 c0       	rjmp	.+40     	; 0xcfe <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     cd6:	8c 81       	ldd	r24, Y+4	; 0x04
     cd8:	9d 81       	ldd	r25, Y+5	; 0x05
     cda:	81 d5       	rcall	.+2818   	; 0x17de <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     cdc:	2c 8d       	ldd	r18, Y+28	; 0x1c
     cde:	8c 81       	ldd	r24, Y+4	; 0x04
     ce0:	9d 81       	ldd	r25, Y+5	; 0x05
     ce2:	82 0f       	add	r24, r18
     ce4:	91 1d       	adc	r25, r1
     ce6:	9d 83       	std	Y+5, r25	; 0x05
     ce8:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     cea:	2a 81       	ldd	r18, Y+2	; 0x02
     cec:	3b 81       	ldd	r19, Y+3	; 0x03
     cee:	82 17       	cp	r24, r18
     cf0:	93 07       	cpc	r25, r19
     cf2:	f0 f0       	brcs	.+60     	; 0xd30 <prvCopyDataToQueue+0x70>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     cf4:	88 81       	ld	r24, Y
     cf6:	99 81       	ldd	r25, Y+1	; 0x01
     cf8:	9d 83       	std	Y+5, r25	; 0x05
     cfa:	8c 83       	std	Y+4, r24	; 0x04
     cfc:	19 c0       	rjmp	.+50     	; 0xd30 <prvCopyDataToQueue+0x70>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     cfe:	8e 81       	ldd	r24, Y+6	; 0x06
     d00:	9f 81       	ldd	r25, Y+7	; 0x07
     d02:	6d d5       	rcall	.+2778   	; 0x17de <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     d04:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	91 95       	neg	r25
     d0a:	81 95       	neg	r24
     d0c:	91 09       	sbc	r25, r1
     d0e:	2e 81       	ldd	r18, Y+6	; 0x06
     d10:	3f 81       	ldd	r19, Y+7	; 0x07
     d12:	28 0f       	add	r18, r24
     d14:	39 1f       	adc	r19, r25
     d16:	3f 83       	std	Y+7, r19	; 0x07
     d18:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     d1a:	48 81       	ld	r20, Y
     d1c:	59 81       	ldd	r21, Y+1	; 0x01
     d1e:	24 17       	cp	r18, r20
     d20:	35 07       	cpc	r19, r21
     d22:	30 f4       	brcc	.+12     	; 0xd30 <prvCopyDataToQueue+0x70>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     d24:	2a 81       	ldd	r18, Y+2	; 0x02
     d26:	3b 81       	ldd	r19, Y+3	; 0x03
     d28:	82 0f       	add	r24, r18
     d2a:	93 1f       	adc	r25, r19
     d2c:	9f 83       	std	Y+7, r25	; 0x07
     d2e:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     d30:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d32:	8f 5f       	subi	r24, 0xFF	; 255
     d34:	8a 8f       	std	Y+26, r24	; 0x1a
}
     d36:	df 91       	pop	r29
     d38:	cf 91       	pop	r28
     d3a:	08 95       	ret

00000d3c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     d3c:	fc 01       	movw	r30, r24
     d3e:	cb 01       	movw	r24, r22
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     d40:	60 81       	ld	r22, Z
     d42:	71 81       	ldd	r23, Z+1	; 0x01
     d44:	61 15       	cp	r22, r1
     d46:	71 05       	cpc	r23, r1
     d48:	91 f0       	breq	.+36     	; 0xd6e <prvCopyDataFromQueue+0x32>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     d4a:	44 8d       	ldd	r20, Z+28	; 0x1c
     d4c:	50 e0       	ldi	r21, 0x00	; 0
     d4e:	26 81       	ldd	r18, Z+6	; 0x06
     d50:	37 81       	ldd	r19, Z+7	; 0x07
     d52:	24 0f       	add	r18, r20
     d54:	35 1f       	adc	r19, r21
     d56:	37 83       	std	Z+7, r19	; 0x07
     d58:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     d5a:	a2 81       	ldd	r26, Z+2	; 0x02
     d5c:	b3 81       	ldd	r27, Z+3	; 0x03
     d5e:	2a 17       	cp	r18, r26
     d60:	3b 07       	cpc	r19, r27
     d62:	10 f0       	brcs	.+4      	; 0xd68 <prvCopyDataFromQueue+0x2c>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     d64:	77 83       	std	Z+7, r23	; 0x07
     d66:	66 83       	std	Z+6, r22	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     d68:	66 81       	ldd	r22, Z+6	; 0x06
     d6a:	77 81       	ldd	r23, Z+7	; 0x07
     d6c:	38 c5       	rjmp	.+2672   	; 0x17de <memcpy>
     d6e:	08 95       	ret

00000d70 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     d70:	0f 93       	push	r16
     d72:	1f 93       	push	r17
     d74:	cf 93       	push	r28
     d76:	df 93       	push	r29
     d78:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     d7a:	0f b6       	in	r0, 0x3f	; 63
     d7c:	f8 94       	cli
     d7e:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d80:	8c 01       	movw	r16, r24
     d82:	0f 5e       	subi	r16, 0xEF	; 239
     d84:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     d86:	8e 8d       	ldd	r24, Y+30	; 0x1e
     d88:	18 16       	cp	r1, r24
     d8a:	5c f4       	brge	.+22     	; 0xda2 <prvUnlockQueue+0x32>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d8c:	89 89       	ldd	r24, Y+17	; 0x11
     d8e:	88 23       	and	r24, r24
     d90:	41 f0       	breq	.+16     	; 0xda2 <prvUnlockQueue+0x32>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d92:	c8 01       	movw	r24, r16
     d94:	82 d4       	rcall	.+2308   	; 0x169a <xTaskRemoveFromEventList>
     d96:	81 11       	cpse	r24, r1
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     d98:	f7 d4       	rcall	.+2542   	; 0x1788 <vTaskMissedYield>
     d9a:	8e 8d       	ldd	r24, Y+30	; 0x1e
				}

				--( pxQueue->xTxLock );
     d9c:	81 50       	subi	r24, 0x01	; 1
     d9e:	8e 8f       	std	Y+30, r24	; 0x1e
     da0:	f2 cf       	rjmp	.-28     	; 0xd86 <prvUnlockQueue+0x16>
     da2:	8f ef       	ldi	r24, 0xFF	; 255
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     da4:	8e 8f       	std	Y+30, r24	; 0x1e
     da6:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
     da8:	0f be       	out	0x3f, r0	; 63
     daa:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     dac:	f8 94       	cli
     dae:	0f 92       	push	r0
     db0:	8e 01       	movw	r16, r28
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     db2:	08 5f       	subi	r16, 0xF8	; 248
     db4:	1f 4f       	sbci	r17, 0xFF	; 255
     db6:	8d 8d       	ldd	r24, Y+29	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     db8:	18 16       	cp	r1, r24
     dba:	5c f4       	brge	.+22     	; 0xdd2 <prvUnlockQueue+0x62>
     dbc:	88 85       	ldd	r24, Y+8	; 0x08
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     dbe:	88 23       	and	r24, r24
     dc0:	41 f0       	breq	.+16     	; 0xdd2 <prvUnlockQueue+0x62>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     dc2:	c8 01       	movw	r24, r16
     dc4:	6a d4       	rcall	.+2260   	; 0x169a <xTaskRemoveFromEventList>
     dc6:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     dc8:	df d4       	rcall	.+2494   	; 0x1788 <vTaskMissedYield>
     dca:	8d 8d       	ldd	r24, Y+29	; 0x1d
				}

				--( pxQueue->xRxLock );
     dcc:	81 50       	subi	r24, 0x01	; 1
     dce:	8d 8f       	std	Y+29, r24	; 0x1d
     dd0:	f2 cf       	rjmp	.-28     	; 0xdb6 <prvUnlockQueue+0x46>
     dd2:	8f ef       	ldi	r24, 0xFF	; 255
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     dd4:	8d 8f       	std	Y+29, r24	; 0x1d
     dd6:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
     dd8:	0f be       	out	0x3f, r0	; 63
     dda:	df 91       	pop	r29
}
     ddc:	cf 91       	pop	r28
     dde:	1f 91       	pop	r17
     de0:	0f 91       	pop	r16
     de2:	08 95       	ret

00000de4 <xQueueCreate>:
     de4:	cf 92       	push	r12
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     de6:	df 92       	push	r13
     de8:	ef 92       	push	r14
     dea:	ff 92       	push	r15
     dec:	0f 93       	push	r16
     dee:	1f 93       	push	r17
     df0:	cf 93       	push	r28
     df2:	df 93       	push	r29
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     df4:	88 23       	and	r24, r24
     df6:	81 f1       	breq	.+96     	; 0xe58 <xQueueCreate+0x74>
     df8:	f6 2e       	mov	r15, r22
     dfa:	e8 2e       	mov	r14, r24
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     dfc:	8f e1       	ldi	r24, 0x1F	; 31
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	1e de       	rcall	.-964    	; 0xa3e <pvPortMalloc>
     e02:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     e04:	89 2b       	or	r24, r25
     e06:	41 f1       	breq	.+80     	; 0xe58 <xQueueCreate+0x74>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     e08:	cf 2c       	mov	r12, r15
     e0a:	d1 2c       	mov	r13, r1
     e0c:	ef 9c       	mul	r14, r15
     e0e:	80 01       	movw	r16, r0
     e10:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     e12:	c8 01       	movw	r24, r16
     e14:	01 96       	adiw	r24, 0x01	; 1
     e16:	13 de       	rcall	.-986    	; 0xa3e <pvPortMalloc>
     e18:	99 83       	std	Y+1, r25	; 0x01
     e1a:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     e1c:	00 97       	sbiw	r24, 0x00	; 0
     e1e:	d1 f0       	breq	.+52     	; 0xe54 <xQueueCreate+0x70>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     e20:	9c 01       	movw	r18, r24
     e22:	20 0f       	add	r18, r16
     e24:	31 1f       	adc	r19, r17
     e26:	3b 83       	std	Y+3, r19	; 0x03
     e28:	2a 83       	std	Y+2, r18	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     e2a:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     e2c:	9d 83       	std	Y+5, r25	; 0x05
     e2e:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     e30:	0c 19       	sub	r16, r12
     e32:	1d 09       	sbc	r17, r13
     e34:	08 0f       	add	r16, r24
     e36:	19 1f       	adc	r17, r25
     e38:	1f 83       	std	Y+7, r17	; 0x07
     e3a:	0e 83       	std	Y+6, r16	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     e3c:	eb 8e       	std	Y+27, r14	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     e3e:	fc 8e       	std	Y+28, r15	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     e40:	8f ef       	ldi	r24, 0xFF	; 255
     e42:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     e44:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     e46:	ce 01       	movw	r24, r28
     e48:	08 96       	adiw	r24, 0x08	; 8
     e4a:	be dc       	rcall	.-1668   	; 0x7c8 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     e4c:	ce 01       	movw	r24, r28
     e4e:	41 96       	adiw	r24, 0x11	; 17
     e50:	bb dc       	rcall	.-1674   	; 0x7c8 <vListInitialise>
     e52:	04 c0       	rjmp	.+8      	; 0xe5c <xQueueCreate+0x78>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     e54:	ce 01       	movw	r24, r28
     e56:	17 de       	rcall	.-978    	; 0xa86 <vPortFree>
     e58:	c0 e0       	ldi	r28, 0x00	; 0

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     e5a:	d0 e0       	ldi	r29, 0x00	; 0
     e5c:	ce 01       	movw	r24, r28
	}

	configASSERT( xReturn );

	return xReturn;
}
     e5e:	df 91       	pop	r29
     e60:	cf 91       	pop	r28
     e62:	1f 91       	pop	r17
     e64:	0f 91       	pop	r16
     e66:	ff 90       	pop	r15
     e68:	ef 90       	pop	r14
     e6a:	df 90       	pop	r13
     e6c:	cf 90       	pop	r12
     e6e:	08 95       	ret

00000e70 <xQueueGenericSend>:
     e70:	af 92       	push	r10

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     e72:	bf 92       	push	r11
     e74:	df 92       	push	r13
     e76:	ef 92       	push	r14
     e78:	ff 92       	push	r15
     e7a:	0f 93       	push	r16
     e7c:	1f 93       	push	r17
     e7e:	cf 93       	push	r28
     e80:	df 93       	push	r29
     e82:	00 d0       	rcall	.+0      	; 0xe84 <xQueueGenericSend+0x14>
     e84:	00 d0       	rcall	.+0      	; 0xe86 <xQueueGenericSend+0x16>
     e86:	1f 92       	push	r1
     e88:	cd b7       	in	r28, 0x3d	; 61
     e8a:	de b7       	in	r29, 0x3e	; 62
     e8c:	8c 01       	movw	r16, r24
     e8e:	7b 01       	movw	r14, r22
     e90:	5d 83       	std	Y+5, r21	; 0x05
     e92:	4c 83       	std	Y+4, r20	; 0x04
     e94:	d2 2e       	mov	r13, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     e96:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e98:	58 01       	movw	r10, r16
     e9a:	98 e0       	ldi	r25, 0x08	; 8
     e9c:	a9 0e       	add	r10, r25
     e9e:	b1 1c       	adc	r11, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     ea0:	0f b6       	in	r0, 0x3f	; 63
     ea2:	f8 94       	cli
     ea4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     ea6:	f8 01       	movw	r30, r16
     ea8:	22 8d       	ldd	r18, Z+26	; 0x1a
     eaa:	93 8d       	ldd	r25, Z+27	; 0x1b
     eac:	29 17       	cp	r18, r25
     eae:	90 f4       	brcc	.+36     	; 0xed4 <xQueueGenericSend+0x64>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     eb0:	4d 2d       	mov	r20, r13
     eb2:	b7 01       	movw	r22, r14
     eb4:	c8 01       	movw	r24, r16
     eb6:	04 df       	rcall	.-504    	; 0xcc0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     eb8:	f8 01       	movw	r30, r16
     eba:	81 89       	ldd	r24, Z+17	; 0x11
     ebc:	88 23       	and	r24, r24
     ebe:	31 f0       	breq	.+12     	; 0xecc <xQueueGenericSend+0x5c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     ec0:	c8 01       	movw	r24, r16
     ec2:	41 96       	adiw	r24, 0x11	; 17
     ec4:	ea d3       	rcall	.+2004   	; 0x169a <xTaskRemoveFromEventList>
     ec6:	81 30       	cpi	r24, 0x01	; 1
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     ec8:	09 f4       	brne	.+2      	; 0xecc <xQueueGenericSend+0x5c>
     eca:	7f de       	rcall	.-770    	; 0xbca <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     ecc:	0f 90       	pop	r0
     ece:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     ed0:	81 e0       	ldi	r24, 0x01	; 1
     ed2:	45 c0       	rjmp	.+138    	; 0xf5e <xQueueGenericSend+0xee>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     ed4:	2c 81       	ldd	r18, Y+4	; 0x04
     ed6:	3d 81       	ldd	r19, Y+5	; 0x05
     ed8:	23 2b       	or	r18, r19
     eda:	19 f4       	brne	.+6      	; 0xee2 <xQueueGenericSend+0x72>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     edc:	0f 90       	pop	r0
     ede:	0f be       	out	0x3f, r0	; 63
     ee0:	3d c0       	rjmp	.+122    	; 0xf5c <xQueueGenericSend+0xec>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
     ee2:	81 11       	cpse	r24, r1
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     ee4:	03 c0       	rjmp	.+6      	; 0xeec <xQueueGenericSend+0x7c>
     ee6:	ce 01       	movw	r24, r28
     ee8:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     eea:	11 d4       	rcall	.+2082   	; 0x170e <vTaskSetTimeOutState>
     eec:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     eee:	0f be       	out	0x3f, r0	; 63
     ef0:	4a d2       	rcall	.+1172   	; 0x1386 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ef2:	0f b6       	in	r0, 0x3f	; 63
     ef4:	f8 94       	cli
     ef6:	0f 92       	push	r0
     ef8:	f8 01       	movw	r30, r16
     efa:	85 8d       	ldd	r24, Z+29	; 0x1d
     efc:	8f 3f       	cpi	r24, 0xFF	; 255
     efe:	09 f4       	brne	.+2      	; 0xf02 <xQueueGenericSend+0x92>
     f00:	15 8e       	std	Z+29, r1	; 0x1d
     f02:	f8 01       	movw	r30, r16
     f04:	86 8d       	ldd	r24, Z+30	; 0x1e
     f06:	8f 3f       	cpi	r24, 0xFF	; 255
     f08:	09 f4       	brne	.+2      	; 0xf0c <xQueueGenericSend+0x9c>
     f0a:	16 8e       	std	Z+30, r1	; 0x1e
     f0c:	0f 90       	pop	r0
     f0e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f10:	be 01       	movw	r22, r28
     f12:	6c 5f       	subi	r22, 0xFC	; 252
     f14:	7f 4f       	sbci	r23, 0xFF	; 255
     f16:	ce 01       	movw	r24, r28
     f18:	01 96       	adiw	r24, 0x01	; 1
     f1a:	04 d4       	rcall	.+2056   	; 0x1724 <xTaskCheckForTimeOut>
     f1c:	81 11       	cpse	r24, r1
     f1e:	1b c0       	rjmp	.+54     	; 0xf56 <xQueueGenericSend+0xe6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     f20:	0f b6       	in	r0, 0x3f	; 63
     f22:	f8 94       	cli
     f24:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     f26:	f8 01       	movw	r30, r16
     f28:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     f2a:	0f 90       	pop	r0
     f2c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     f2e:	83 8d       	ldd	r24, Z+27	; 0x1b
     f30:	98 13       	cpse	r25, r24
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f32:	0d c0       	rjmp	.+26     	; 0xf4e <xQueueGenericSend+0xde>
     f34:	6c 81       	ldd	r22, Y+4	; 0x04
     f36:	7d 81       	ldd	r23, Y+5	; 0x05
     f38:	c5 01       	movw	r24, r10
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     f3a:	96 d3       	rcall	.+1836   	; 0x1668 <vTaskPlaceOnEventList>
     f3c:	c8 01       	movw	r24, r16
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     f3e:	18 df       	rcall	.-464    	; 0xd70 <prvUnlockQueue>
     f40:	c4 d2       	rcall	.+1416   	; 0x14ca <xTaskResumeAll>
     f42:	88 23       	and	r24, r24
     f44:	11 f0       	breq	.+4      	; 0xf4a <xQueueGenericSend+0xda>
				{
					portYIELD_WITHIN_API();
     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	ab cf       	rjmp	.-170    	; 0xea0 <xQueueGenericSend+0x30>
     f4a:	3f de       	rcall	.-898    	; 0xbca <vPortYield>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f4c:	fc cf       	rjmp	.-8      	; 0xf46 <xQueueGenericSend+0xd6>
     f4e:	c8 01       	movw	r24, r16
     f50:	0f df       	rcall	.-482    	; 0xd70 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f52:	bb d2       	rcall	.+1398   	; 0x14ca <xTaskResumeAll>
     f54:	f8 cf       	rjmp	.-16     	; 0xf46 <xQueueGenericSend+0xd6>
     f56:	c8 01       	movw	r24, r16
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     f58:	0b df       	rcall	.-490    	; 0xd70 <prvUnlockQueue>
     f5a:	b7 d2       	rcall	.+1390   	; 0x14ca <xTaskResumeAll>
     f5c:	80 e0       	ldi	r24, 0x00	; 0
			( void ) xTaskResumeAll();
     f5e:	0f 90       	pop	r0
     f60:	0f 90       	pop	r0

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     f62:	0f 90       	pop	r0
		}
	}
}
     f64:	0f 90       	pop	r0
     f66:	0f 90       	pop	r0
     f68:	df 91       	pop	r29
     f6a:	cf 91       	pop	r28
     f6c:	1f 91       	pop	r17
     f6e:	0f 91       	pop	r16
     f70:	ff 90       	pop	r15
     f72:	ef 90       	pop	r14
     f74:	df 90       	pop	r13
     f76:	bf 90       	pop	r11
     f78:	af 90       	pop	r10
     f7a:	08 95       	ret

00000f7c <xQueueGenericSendFromISR>:
     f7c:	0f 93       	push	r16
     f7e:	1f 93       	push	r17
     f80:	cf 93       	push	r28

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     f82:	df 93       	push	r29
     f84:	ec 01       	movw	r28, r24
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     f86:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f88:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f8a:	98 17       	cp	r25, r24
     f8c:	b8 f4       	brcc	.+46     	; 0xfbc <xQueueGenericSendFromISR+0x40>
     f8e:	8a 01       	movw	r16, r20
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f90:	42 2f       	mov	r20, r18
     f92:	ce 01       	movw	r24, r28
     f94:	95 de       	rcall	.-726    	; 0xcc0 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     f96:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f98:	8f 3f       	cpi	r24, 0xFF	; 255
     f9a:	61 f4       	brne	.+24     	; 0xfb4 <xQueueGenericSendFromISR+0x38>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f9c:	89 89       	ldd	r24, Y+17	; 0x11
     f9e:	88 23       	and	r24, r24
     fa0:	59 f0       	breq	.+22     	; 0xfb8 <xQueueGenericSendFromISR+0x3c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fa2:	ce 01       	movw	r24, r28
     fa4:	41 96       	adiw	r24, 0x11	; 17
     fa6:	79 d3       	rcall	.+1778   	; 0x169a <xTaskRemoveFromEventList>
     fa8:	88 23       	and	r24, r24
     faa:	31 f0       	breq	.+12     	; 0xfb8 <xQueueGenericSendFromISR+0x3c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     fac:	81 e0       	ldi	r24, 0x01	; 1
     fae:	f8 01       	movw	r30, r16
     fb0:	80 83       	st	Z, r24
     fb2:	05 c0       	rjmp	.+10     	; 0xfbe <xQueueGenericSendFromISR+0x42>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     fb4:	8f 5f       	subi	r24, 0xFF	; 255
     fb6:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     fb8:	81 e0       	ldi	r24, 0x01	; 1
     fba:	01 c0       	rjmp	.+2      	; 0xfbe <xQueueGenericSendFromISR+0x42>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     fbc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     fbe:	df 91       	pop	r29
     fc0:	cf 91       	pop	r28
     fc2:	1f 91       	pop	r17
     fc4:	0f 91       	pop	r16
     fc6:	08 95       	ret

00000fc8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     fc8:	af 92       	push	r10
     fca:	bf 92       	push	r11
     fcc:	df 92       	push	r13
     fce:	ef 92       	push	r14
     fd0:	ff 92       	push	r15
     fd2:	0f 93       	push	r16
     fd4:	1f 93       	push	r17
     fd6:	cf 93       	push	r28
     fd8:	df 93       	push	r29
     fda:	00 d0       	rcall	.+0      	; 0xfdc <xQueueGenericReceive+0x14>
     fdc:	00 d0       	rcall	.+0      	; 0xfde <xQueueGenericReceive+0x16>
     fde:	1f 92       	push	r1
     fe0:	cd b7       	in	r28, 0x3d	; 61
     fe2:	de b7       	in	r29, 0x3e	; 62
     fe4:	8c 01       	movw	r16, r24
     fe6:	7b 01       	movw	r14, r22
     fe8:	5d 83       	std	Y+5, r21	; 0x05
     fea:	4c 83       	std	Y+4, r20	; 0x04
     fec:	d2 2e       	mov	r13, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     fee:	80 e0       	ldi	r24, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ff0:	58 01       	movw	r10, r16
     ff2:	91 e1       	ldi	r25, 0x11	; 17
     ff4:	a9 0e       	add	r10, r25
     ff6:	b1 1c       	adc	r11, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     ff8:	0f b6       	in	r0, 0x3f	; 63
     ffa:	f8 94       	cli
     ffc:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     ffe:	f8 01       	movw	r30, r16
    1000:	92 8d       	ldd	r25, Z+26	; 0x1a
    1002:	99 23       	and	r25, r25
    1004:	19 f1       	breq	.+70     	; 0x104c <xQueueGenericReceive+0x84>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1006:	a6 80       	ldd	r10, Z+6	; 0x06
    1008:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    100a:	b7 01       	movw	r22, r14
    100c:	c8 01       	movw	r24, r16
    100e:	96 de       	rcall	.-724    	; 0xd3c <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1010:	f8 01       	movw	r30, r16
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1012:	d1 10       	cpse	r13, r1
    1014:	0d c0       	rjmp	.+26     	; 0x1030 <xQueueGenericReceive+0x68>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1016:	82 8d       	ldd	r24, Z+26	; 0x1a
    1018:	81 50       	subi	r24, 0x01	; 1
    101a:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    101c:	80 85       	ldd	r24, Z+8	; 0x08
    101e:	88 23       	and	r24, r24
    1020:	89 f0       	breq	.+34     	; 0x1044 <xQueueGenericReceive+0x7c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1022:	c8 01       	movw	r24, r16
    1024:	08 96       	adiw	r24, 0x08	; 8
    1026:	39 d3       	rcall	.+1650   	; 0x169a <xTaskRemoveFromEventList>
    1028:	81 30       	cpi	r24, 0x01	; 1
						{
							portYIELD_WITHIN_API();
    102a:	61 f4       	brne	.+24     	; 0x1044 <xQueueGenericReceive+0x7c>
    102c:	ce dd       	rcall	.-1124   	; 0xbca <vPortYield>
    102e:	0a c0       	rjmp	.+20     	; 0x1044 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1030:	b7 82       	std	Z+7, r11	; 0x07
    1032:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1034:	81 89       	ldd	r24, Z+17	; 0x11
    1036:	88 23       	and	r24, r24
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1038:	29 f0       	breq	.+10     	; 0x1044 <xQueueGenericReceive+0x7c>
    103a:	c8 01       	movw	r24, r16
    103c:	41 96       	adiw	r24, 0x11	; 17
    103e:	2d d3       	rcall	.+1626   	; 0x169a <xTaskRemoveFromEventList>
    1040:	81 11       	cpse	r24, r1
    1042:	f4 cf       	rjmp	.-24     	; 0x102c <xQueueGenericReceive+0x64>
						}
					}

				}

				taskEXIT_CRITICAL();
    1044:	0f 90       	pop	r0
    1046:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1048:	81 e0       	ldi	r24, 0x01	; 1
    104a:	44 c0       	rjmp	.+136    	; 0x10d4 <xQueueGenericReceive+0x10c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    104c:	2c 81       	ldd	r18, Y+4	; 0x04
    104e:	3d 81       	ldd	r19, Y+5	; 0x05
    1050:	23 2b       	or	r18, r19
    1052:	19 f4       	brne	.+6      	; 0x105a <xQueueGenericReceive+0x92>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1054:	0f 90       	pop	r0
    1056:	0f be       	out	0x3f, r0	; 63
    1058:	3c c0       	rjmp	.+120    	; 0x10d2 <xQueueGenericReceive+0x10a>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    105a:	81 11       	cpse	r24, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    105c:	03 c0       	rjmp	.+6      	; 0x1064 <xQueueGenericReceive+0x9c>
    105e:	ce 01       	movw	r24, r28
    1060:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    1062:	55 d3       	rcall	.+1706   	; 0x170e <vTaskSetTimeOutState>
    1064:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1066:	0f be       	out	0x3f, r0	; 63
    1068:	8e d1       	rcall	.+796    	; 0x1386 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    106a:	0f b6       	in	r0, 0x3f	; 63
    106c:	f8 94       	cli
    106e:	0f 92       	push	r0
    1070:	f8 01       	movw	r30, r16
    1072:	85 8d       	ldd	r24, Z+29	; 0x1d
    1074:	8f 3f       	cpi	r24, 0xFF	; 255
    1076:	09 f4       	brne	.+2      	; 0x107a <xQueueGenericReceive+0xb2>
    1078:	15 8e       	std	Z+29, r1	; 0x1d
    107a:	f8 01       	movw	r30, r16
    107c:	86 8d       	ldd	r24, Z+30	; 0x1e
    107e:	8f 3f       	cpi	r24, 0xFF	; 255
    1080:	09 f4       	brne	.+2      	; 0x1084 <xQueueGenericReceive+0xbc>
    1082:	16 8e       	std	Z+30, r1	; 0x1e
    1084:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1086:	0f be       	out	0x3f, r0	; 63
    1088:	be 01       	movw	r22, r28
    108a:	6c 5f       	subi	r22, 0xFC	; 252
    108c:	7f 4f       	sbci	r23, 0xFF	; 255
    108e:	ce 01       	movw	r24, r28
    1090:	01 96       	adiw	r24, 0x01	; 1
    1092:	48 d3       	rcall	.+1680   	; 0x1724 <xTaskCheckForTimeOut>
    1094:	81 11       	cpse	r24, r1
    1096:	1a c0       	rjmp	.+52     	; 0x10cc <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1098:	0f b6       	in	r0, 0x3f	; 63
    109a:	f8 94       	cli
    109c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    109e:	f8 01       	movw	r30, r16
    10a0:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    10a2:	0f 90       	pop	r0
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    10a4:	0f be       	out	0x3f, r0	; 63
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    10a6:	81 11       	cpse	r24, r1
    10a8:	0d c0       	rjmp	.+26     	; 0x10c4 <xQueueGenericReceive+0xfc>
    10aa:	6c 81       	ldd	r22, Y+4	; 0x04
    10ac:	7d 81       	ldd	r23, Y+5	; 0x05
				prvUnlockQueue( pxQueue );
    10ae:	c5 01       	movw	r24, r10
    10b0:	db d2       	rcall	.+1462   	; 0x1668 <vTaskPlaceOnEventList>
				if( xTaskResumeAll() == pdFALSE )
    10b2:	c8 01       	movw	r24, r16
    10b4:	5d de       	rcall	.-838    	; 0xd70 <prvUnlockQueue>
    10b6:	09 d2       	rcall	.+1042   	; 0x14ca <xTaskResumeAll>
    10b8:	88 23       	and	r24, r24
				{
					portYIELD_WITHIN_API();
    10ba:	11 f0       	breq	.+4      	; 0x10c0 <xQueueGenericReceive+0xf8>
    10bc:	81 e0       	ldi	r24, 0x01	; 1
    10be:	9c cf       	rjmp	.-200    	; 0xff8 <xQueueGenericReceive+0x30>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    10c0:	84 dd       	rcall	.-1272   	; 0xbca <vPortYield>
    10c2:	fc cf       	rjmp	.-8      	; 0x10bc <xQueueGenericReceive+0xf4>
    10c4:	c8 01       	movw	r24, r16
				( void ) xTaskResumeAll();
    10c6:	54 de       	rcall	.-856    	; 0xd70 <prvUnlockQueue>
    10c8:	00 d2       	rcall	.+1024   	; 0x14ca <xTaskResumeAll>
    10ca:	f8 cf       	rjmp	.-16     	; 0x10bc <xQueueGenericReceive+0xf4>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    10cc:	c8 01       	movw	r24, r16
    10ce:	50 de       	rcall	.-864    	; 0xd70 <prvUnlockQueue>
    10d0:	fc d1       	rcall	.+1016   	; 0x14ca <xTaskResumeAll>
			( void ) xTaskResumeAll();
    10d2:	80 e0       	ldi	r24, 0x00	; 0
    10d4:	0f 90       	pop	r0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    10d6:	0f 90       	pop	r0
		}
	}
}
    10d8:	0f 90       	pop	r0
    10da:	0f 90       	pop	r0
    10dc:	0f 90       	pop	r0
    10de:	df 91       	pop	r29
    10e0:	cf 91       	pop	r28
    10e2:	1f 91       	pop	r17
    10e4:	0f 91       	pop	r16
    10e6:	ff 90       	pop	r15
    10e8:	ef 90       	pop	r14
    10ea:	df 90       	pop	r13
    10ec:	bf 90       	pop	r11
    10ee:	af 90       	pop	r10
    10f0:	08 95       	ret

000010f2 <prvIdleTask>:
    10f2:	6b dd       	rcall	.-1322   	; 0xbca <vPortYield>
    10f4:	fe cf       	rjmp	.-4      	; 0x10f2 <prvIdleTask>

000010f6 <prvAddCurrentTaskToDelayedList>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	e0 91 cb 06 	lds	r30, 0x06CB	; 0x8006cb <pxCurrentTCB>
    10fe:	f0 91 cc 06 	lds	r31, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
    1102:	93 83       	std	Z+3, r25	; 0x03
    1104:	82 83       	std	Z+2, r24	; 0x02
    1106:	20 91 85 06 	lds	r18, 0x0685	; 0x800685 <xTickCount>
    110a:	30 91 86 06 	lds	r19, 0x0686	; 0x800686 <xTickCount+0x1>
    110e:	82 17       	cp	r24, r18
    1110:	93 07       	cpc	r25, r19
    1112:	68 f4       	brcc	.+26     	; 0x112e <prvAddCurrentTaskToDelayedList+0x38>
    1114:	60 91 cb 06 	lds	r22, 0x06CB	; 0x8006cb <pxCurrentTCB>
    1118:	70 91 cc 06 	lds	r23, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
    111c:	80 91 91 06 	lds	r24, 0x0691	; 0x800691 <pxOverflowDelayedTaskList>
    1120:	90 91 92 06 	lds	r25, 0x0692	; 0x800692 <pxOverflowDelayedTaskList+0x1>
    1124:	6e 5f       	subi	r22, 0xFE	; 254
    1126:	7f 4f       	sbci	r23, 0xFF	; 255
    1128:	df 91       	pop	r29
    112a:	cf 91       	pop	r28
    112c:	82 cb       	rjmp	.-2300   	; 0x832 <vListInsert>
    112e:	ec 01       	movw	r28, r24
    1130:	60 91 cb 06 	lds	r22, 0x06CB	; 0x8006cb <pxCurrentTCB>
    1134:	70 91 cc 06 	lds	r23, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
    1138:	80 91 93 06 	lds	r24, 0x0693	; 0x800693 <pxDelayedTaskList>
    113c:	90 91 94 06 	lds	r25, 0x0694	; 0x800694 <pxDelayedTaskList+0x1>
    1140:	6e 5f       	subi	r22, 0xFE	; 254
    1142:	7f 4f       	sbci	r23, 0xFF	; 255
    1144:	76 db       	rcall	.-2324   	; 0x832 <vListInsert>
    1146:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <xNextTaskUnblockTime>
    114a:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <xNextTaskUnblockTime+0x1>
    114e:	c8 17       	cp	r28, r24
    1150:	d9 07       	cpc	r29, r25
    1152:	20 f4       	brcc	.+8      	; 0x115c <prvAddCurrentTaskToDelayedList+0x66>
    1154:	d0 93 65 00 	sts	0x0065, r29	; 0x800065 <xNextTaskUnblockTime+0x1>
    1158:	c0 93 64 00 	sts	0x0064, r28	; 0x800064 <xNextTaskUnblockTime>
    115c:	df 91       	pop	r29
    115e:	cf 91       	pop	r28
    1160:	08 95       	ret

00001162 <xTaskGenericCreate>:
    1162:	4f 92       	push	r4
    1164:	5f 92       	push	r5
    1166:	6f 92       	push	r6
    1168:	7f 92       	push	r7
    116a:	8f 92       	push	r8
    116c:	9f 92       	push	r9
    116e:	af 92       	push	r10
    1170:	bf 92       	push	r11
    1172:	cf 92       	push	r12
    1174:	df 92       	push	r13
    1176:	ef 92       	push	r14
    1178:	ff 92       	push	r15
    117a:	0f 93       	push	r16
    117c:	1f 93       	push	r17
    117e:	cf 93       	push	r28
    1180:	df 93       	push	r29
    1182:	2c 01       	movw	r4, r24
    1184:	3b 01       	movw	r6, r22
    1186:	5a 01       	movw	r10, r20
    1188:	49 01       	movw	r8, r18
    118a:	81 e2       	ldi	r24, 0x21	; 33
    118c:	90 e0       	ldi	r25, 0x00	; 0
    118e:	57 dc       	rcall	.-1874   	; 0xa3e <pvPortMalloc>
    1190:	ec 01       	movw	r28, r24
    1192:	89 2b       	or	r24, r25
    1194:	09 f4       	brne	.+2      	; 0x1198 <xTaskGenericCreate+0x36>
    1196:	b5 c0       	rjmp	.+362    	; 0x1302 <xTaskGenericCreate+0x1a0>
    1198:	c1 14       	cp	r12, r1
    119a:	d1 04       	cpc	r13, r1
    119c:	19 f4       	brne	.+6      	; 0x11a4 <xTaskGenericCreate+0x42>
    119e:	c5 01       	movw	r24, r10
    11a0:	4e dc       	rcall	.-1892   	; 0xa3e <pvPortMalloc>
    11a2:	01 c0       	rjmp	.+2      	; 0x11a6 <xTaskGenericCreate+0x44>
    11a4:	c6 01       	movw	r24, r12
    11a6:	98 8f       	std	Y+24, r25	; 0x18
    11a8:	8f 8b       	std	Y+23, r24	; 0x17
    11aa:	00 97       	sbiw	r24, 0x00	; 0
    11ac:	19 f4       	brne	.+6      	; 0x11b4 <xTaskGenericCreate+0x52>
    11ae:	ce 01       	movw	r24, r28
    11b0:	6a dc       	rcall	.-1836   	; 0xa86 <vPortFree>
    11b2:	a7 c0       	rjmp	.+334    	; 0x1302 <xTaskGenericCreate+0x1a0>
    11b4:	a5 01       	movw	r20, r10
    11b6:	65 ea       	ldi	r22, 0xA5	; 165
    11b8:	70 e0       	ldi	r23, 0x00	; 0
    11ba:	1a d3       	rcall	.+1588   	; 0x17f0 <memset>
    11bc:	21 e0       	ldi	r18, 0x01	; 1
    11be:	a2 1a       	sub	r10, r18
    11c0:	b1 08       	sbc	r11, r1
    11c2:	8f 89       	ldd	r24, Y+23	; 0x17
    11c4:	98 8d       	ldd	r25, Y+24	; 0x18
    11c6:	a8 0e       	add	r10, r24
    11c8:	b9 1e       	adc	r11, r25
    11ca:	48 e0       	ldi	r20, 0x08	; 8
    11cc:	50 e0       	ldi	r21, 0x00	; 0
    11ce:	b3 01       	movw	r22, r6
    11d0:	ce 01       	movw	r24, r28
    11d2:	49 96       	adiw	r24, 0x19	; 25
    11d4:	14 d3       	rcall	.+1576   	; 0x17fe <strncpy>
    11d6:	18 a2       	std	Y+32, r1	; 0x20
    11d8:	10 2f       	mov	r17, r16
    11da:	04 30       	cpi	r16, 0x04	; 4
    11dc:	08 f0       	brcs	.+2      	; 0x11e0 <xTaskGenericCreate+0x7e>
    11de:	13 e0       	ldi	r17, 0x03	; 3
    11e0:	1e 8b       	std	Y+22, r17	; 0x16
    11e2:	6e 01       	movw	r12, r28
    11e4:	82 e0       	ldi	r24, 0x02	; 2
    11e6:	c8 0e       	add	r12, r24
    11e8:	d1 1c       	adc	r13, r1
    11ea:	c6 01       	movw	r24, r12
    11ec:	fb da       	rcall	.-2570   	; 0x7e4 <vListInitialiseItem>
    11ee:	ce 01       	movw	r24, r28
    11f0:	0c 96       	adiw	r24, 0x0c	; 12
    11f2:	f8 da       	rcall	.-2576   	; 0x7e4 <vListInitialiseItem>
    11f4:	d9 87       	std	Y+9, r29	; 0x09
    11f6:	c8 87       	std	Y+8, r28	; 0x08
    11f8:	84 e0       	ldi	r24, 0x04	; 4
    11fa:	90 e0       	ldi	r25, 0x00	; 0
    11fc:	81 1b       	sub	r24, r17
    11fe:	91 09       	sbc	r25, r1
    1200:	9d 87       	std	Y+13, r25	; 0x0d
    1202:	8c 87       	std	Y+12, r24	; 0x0c
    1204:	db 8b       	std	Y+19, r29	; 0x13
    1206:	ca 8b       	std	Y+18, r28	; 0x12
    1208:	a4 01       	movw	r20, r8
    120a:	b2 01       	movw	r22, r4
    120c:	c5 01       	movw	r24, r10
    120e:	3c dc       	rcall	.-1928   	; 0xa88 <pxPortInitialiseStack>
    1210:	99 83       	std	Y+1, r25	; 0x01
    1212:	88 83       	st	Y, r24
    1214:	e1 14       	cp	r14, r1
    1216:	f1 04       	cpc	r15, r1
    1218:	19 f0       	breq	.+6      	; 0x1220 <xTaskGenericCreate+0xbe>
    121a:	f7 01       	movw	r30, r14
    121c:	d1 83       	std	Z+1, r29	; 0x01
    121e:	c0 83       	st	Z, r28
    1220:	0f b6       	in	r0, 0x3f	; 63
    1222:	f8 94       	cli
    1224:	0f 92       	push	r0
    1226:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <uxCurrentNumberOfTasks>
    122a:	8f 5f       	subi	r24, 0xFF	; 255
    122c:	80 93 87 06 	sts	0x0687, r24	; 0x800687 <uxCurrentNumberOfTasks>
    1230:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <pxCurrentTCB>
    1234:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
    1238:	89 2b       	or	r24, r25
    123a:	51 f5       	brne	.+84     	; 0x1290 <xTaskGenericCreate+0x12e>
    123c:	d0 93 cc 06 	sts	0x06CC, r29	; 0x8006cc <pxCurrentTCB+0x1>
    1240:	c0 93 cb 06 	sts	0x06CB, r28	; 0x8006cb <pxCurrentTCB>
    1244:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <uxCurrentNumberOfTasks>
    1248:	81 30       	cpi	r24, 0x01	; 1
    124a:	89 f5       	brne	.+98     	; 0x12ae <xTaskGenericCreate+0x14c>
    124c:	87 ea       	ldi	r24, 0xA7	; 167
    124e:	96 e0       	ldi	r25, 0x06	; 6
    1250:	bb da       	rcall	.-2698   	; 0x7c8 <vListInitialise>
    1252:	80 eb       	ldi	r24, 0xB0	; 176
    1254:	96 e0       	ldi	r25, 0x06	; 6
    1256:	b8 da       	rcall	.-2704   	; 0x7c8 <vListInitialise>
    1258:	89 eb       	ldi	r24, 0xB9	; 185
    125a:	96 e0       	ldi	r25, 0x06	; 6
    125c:	b5 da       	rcall	.-2710   	; 0x7c8 <vListInitialise>
    125e:	82 ec       	ldi	r24, 0xC2	; 194
    1260:	96 e0       	ldi	r25, 0x06	; 6
    1262:	b2 da       	rcall	.-2716   	; 0x7c8 <vListInitialise>
    1264:	8e e9       	ldi	r24, 0x9E	; 158
    1266:	96 e0       	ldi	r25, 0x06	; 6
    1268:	af da       	rcall	.-2722   	; 0x7c8 <vListInitialise>
    126a:	85 e9       	ldi	r24, 0x95	; 149
    126c:	96 e0       	ldi	r25, 0x06	; 6
    126e:	ac da       	rcall	.-2728   	; 0x7c8 <vListInitialise>
    1270:	88 e8       	ldi	r24, 0x88	; 136
    1272:	96 e0       	ldi	r25, 0x06	; 6
    1274:	a9 da       	rcall	.-2734   	; 0x7c8 <vListInitialise>
    1276:	8e e9       	ldi	r24, 0x9E	; 158
    1278:	96 e0       	ldi	r25, 0x06	; 6
    127a:	90 93 94 06 	sts	0x0694, r25	; 0x800694 <pxDelayedTaskList+0x1>
    127e:	80 93 93 06 	sts	0x0693, r24	; 0x800693 <pxDelayedTaskList>
    1282:	85 e9       	ldi	r24, 0x95	; 149
    1284:	96 e0       	ldi	r25, 0x06	; 6
    1286:	90 93 92 06 	sts	0x0692, r25	; 0x800692 <pxOverflowDelayedTaskList+0x1>
    128a:	80 93 91 06 	sts	0x0691, r24	; 0x800691 <pxOverflowDelayedTaskList>
    128e:	0f c0       	rjmp	.+30     	; 0x12ae <xTaskGenericCreate+0x14c>
    1290:	80 91 82 06 	lds	r24, 0x0682	; 0x800682 <xSchedulerRunning>
    1294:	81 11       	cpse	r24, r1
    1296:	0b c0       	rjmp	.+22     	; 0x12ae <xTaskGenericCreate+0x14c>
    1298:	e0 91 cb 06 	lds	r30, 0x06CB	; 0x8006cb <pxCurrentTCB>
    129c:	f0 91 cc 06 	lds	r31, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
    12a0:	86 89       	ldd	r24, Z+22	; 0x16
    12a2:	08 17       	cp	r16, r24
    12a4:	20 f0       	brcs	.+8      	; 0x12ae <xTaskGenericCreate+0x14c>
    12a6:	d0 93 cc 06 	sts	0x06CC, r29	; 0x8006cc <pxCurrentTCB+0x1>
    12aa:	c0 93 cb 06 	sts	0x06CB, r28	; 0x8006cb <pxCurrentTCB>
    12ae:	8e 89       	ldd	r24, Y+22	; 0x16
    12b0:	90 91 84 06 	lds	r25, 0x0684	; 0x800684 <uxTopUsedPriority>
    12b4:	98 17       	cp	r25, r24
    12b6:	10 f4       	brcc	.+4      	; 0x12bc <xTaskGenericCreate+0x15a>
    12b8:	80 93 84 06 	sts	0x0684, r24	; 0x800684 <uxTopUsedPriority>
    12bc:	90 91 7d 06 	lds	r25, 0x067D	; 0x80067d <uxTaskNumber>
    12c0:	9f 5f       	subi	r25, 0xFF	; 255
    12c2:	90 93 7d 06 	sts	0x067D, r25	; 0x80067d <uxTaskNumber>
    12c6:	90 91 83 06 	lds	r25, 0x0683	; 0x800683 <uxTopReadyPriority>
    12ca:	98 17       	cp	r25, r24
    12cc:	10 f4       	brcc	.+4      	; 0x12d2 <xTaskGenericCreate+0x170>
    12ce:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <uxTopReadyPriority>
    12d2:	f9 e0       	ldi	r31, 0x09	; 9
    12d4:	8f 9f       	mul	r24, r31
    12d6:	c0 01       	movw	r24, r0
    12d8:	11 24       	eor	r1, r1
    12da:	b6 01       	movw	r22, r12
    12dc:	89 55       	subi	r24, 0x59	; 89
    12de:	99 4f       	sbci	r25, 0xF9	; 249
    12e0:	85 da       	rcall	.-2806   	; 0x7ec <vListInsertEnd>
    12e2:	0f 90       	pop	r0
    12e4:	0f be       	out	0x3f, r0	; 63
    12e6:	80 91 82 06 	lds	r24, 0x0682	; 0x800682 <xSchedulerRunning>
    12ea:	88 23       	and	r24, r24
    12ec:	41 f0       	breq	.+16     	; 0x12fe <xTaskGenericCreate+0x19c>
    12ee:	e0 91 cb 06 	lds	r30, 0x06CB	; 0x8006cb <pxCurrentTCB>
    12f2:	f0 91 cc 06 	lds	r31, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
    12f6:	86 89       	ldd	r24, Z+22	; 0x16
    12f8:	80 17       	cp	r24, r16
    12fa:	08 f4       	brcc	.+2      	; 0x12fe <xTaskGenericCreate+0x19c>
    12fc:	66 dc       	rcall	.-1844   	; 0xbca <vPortYield>
    12fe:	81 e0       	ldi	r24, 0x01	; 1
    1300:	01 c0       	rjmp	.+2      	; 0x1304 <xTaskGenericCreate+0x1a2>
    1302:	8f ef       	ldi	r24, 0xFF	; 255
    1304:	df 91       	pop	r29
    1306:	cf 91       	pop	r28
    1308:	1f 91       	pop	r17
    130a:	0f 91       	pop	r16
    130c:	ff 90       	pop	r15
    130e:	ef 90       	pop	r14
    1310:	df 90       	pop	r13
    1312:	cf 90       	pop	r12
    1314:	bf 90       	pop	r11
    1316:	af 90       	pop	r10
    1318:	9f 90       	pop	r9
    131a:	8f 90       	pop	r8
    131c:	7f 90       	pop	r7
    131e:	6f 90       	pop	r6
    1320:	5f 90       	pop	r5
    1322:	4f 90       	pop	r4
    1324:	08 95       	ret

00001326 <vTaskStartScheduler>:
    1326:	af 92       	push	r10
    1328:	bf 92       	push	r11
    132a:	cf 92       	push	r12
    132c:	df 92       	push	r13
    132e:	ef 92       	push	r14
    1330:	ff 92       	push	r15
    1332:	0f 93       	push	r16
    1334:	a1 2c       	mov	r10, r1
    1336:	b1 2c       	mov	r11, r1
    1338:	c1 2c       	mov	r12, r1
    133a:	d1 2c       	mov	r13, r1
    133c:	e1 2c       	mov	r14, r1
    133e:	f1 2c       	mov	r15, r1
    1340:	00 e0       	ldi	r16, 0x00	; 0
    1342:	20 e0       	ldi	r18, 0x00	; 0
    1344:	30 e0       	ldi	r19, 0x00	; 0
    1346:	45 e5       	ldi	r20, 0x55	; 85
    1348:	50 e0       	ldi	r21, 0x00	; 0
    134a:	61 e9       	ldi	r22, 0x91	; 145
    134c:	70 e0       	ldi	r23, 0x00	; 0
    134e:	89 e7       	ldi	r24, 0x79	; 121
    1350:	98 e0       	ldi	r25, 0x08	; 8
    1352:	07 df       	rcall	.-498    	; 0x1162 <xTaskGenericCreate>
    1354:	81 30       	cpi	r24, 0x01	; 1
    1356:	79 f4       	brne	.+30     	; 0x1376 <vTaskStartScheduler+0x50>
    1358:	f8 94       	cli
    135a:	80 93 82 06 	sts	0x0682, r24	; 0x800682 <xSchedulerRunning>
    135e:	10 92 86 06 	sts	0x0686, r1	; 0x800686 <xTickCount+0x1>
    1362:	10 92 85 06 	sts	0x0685, r1	; 0x800685 <xTickCount>
    1366:	0f 91       	pop	r16
    1368:	ff 90       	pop	r15
    136a:	ef 90       	pop	r14
    136c:	df 90       	pop	r13
    136e:	cf 90       	pop	r12
    1370:	bf 90       	pop	r11
    1372:	af 90       	pop	r10
    1374:	f5 cb       	rjmp	.-2070   	; 0xb60 <xPortStartScheduler>
    1376:	0f 91       	pop	r16
    1378:	ff 90       	pop	r15
    137a:	ef 90       	pop	r14
    137c:	df 90       	pop	r13
    137e:	cf 90       	pop	r12
    1380:	bf 90       	pop	r11
    1382:	af 90       	pop	r10
    1384:	08 95       	ret

00001386 <vTaskSuspendAll>:
    1386:	80 91 81 06 	lds	r24, 0x0681	; 0x800681 <uxSchedulerSuspended>
    138a:	8f 5f       	subi	r24, 0xFF	; 255
    138c:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <uxSchedulerSuspended>
    1390:	08 95       	ret

00001392 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1392:	ff 92       	push	r15
    1394:	0f 93       	push	r16
    1396:	1f 93       	push	r17
    1398:	cf 93       	push	r28
    139a:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    139c:	80 91 81 06 	lds	r24, 0x0681	; 0x800681 <uxSchedulerSuspended>
    13a0:	81 11       	cpse	r24, r1
    13a2:	88 c0       	rjmp	.+272    	; 0x14b4 <vTaskIncrementTick+0x122>
	{
		++xTickCount;
    13a4:	80 91 85 06 	lds	r24, 0x0685	; 0x800685 <xTickCount>
    13a8:	90 91 86 06 	lds	r25, 0x0686	; 0x800686 <xTickCount+0x1>
    13ac:	01 96       	adiw	r24, 0x01	; 1
    13ae:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <xTickCount+0x1>
    13b2:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <xTickCount>
		if( xTickCount == ( portTickType ) 0U )
    13b6:	80 91 85 06 	lds	r24, 0x0685	; 0x800685 <xTickCount>
    13ba:	90 91 86 06 	lds	r25, 0x0686	; 0x800686 <xTickCount+0x1>
    13be:	89 2b       	or	r24, r25
    13c0:	79 f5       	brne	.+94     	; 0x1420 <vTaskIncrementTick+0x8e>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    13c2:	80 91 93 06 	lds	r24, 0x0693	; 0x800693 <pxDelayedTaskList>
    13c6:	90 91 94 06 	lds	r25, 0x0694	; 0x800694 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    13ca:	20 91 91 06 	lds	r18, 0x0691	; 0x800691 <pxOverflowDelayedTaskList>
    13ce:	30 91 92 06 	lds	r19, 0x0692	; 0x800692 <pxOverflowDelayedTaskList+0x1>
    13d2:	30 93 94 06 	sts	0x0694, r19	; 0x800694 <pxDelayedTaskList+0x1>
    13d6:	20 93 93 06 	sts	0x0693, r18	; 0x800693 <pxDelayedTaskList>
			pxOverflowDelayedTaskList = pxTemp;
    13da:	90 93 92 06 	sts	0x0692, r25	; 0x800692 <pxOverflowDelayedTaskList+0x1>
    13de:	80 93 91 06 	sts	0x0691, r24	; 0x800691 <pxOverflowDelayedTaskList>
			xNumOfOverflows++;
    13e2:	80 91 7e 06 	lds	r24, 0x067E	; 0x80067e <xNumOfOverflows>
    13e6:	8f 5f       	subi	r24, 0xFF	; 255
    13e8:	80 93 7e 06 	sts	0x067E, r24	; 0x80067e <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    13ec:	e0 91 93 06 	lds	r30, 0x0693	; 0x800693 <pxDelayedTaskList>
    13f0:	f0 91 94 06 	lds	r31, 0x0694	; 0x800694 <pxDelayedTaskList+0x1>
    13f4:	80 81       	ld	r24, Z
    13f6:	81 11       	cpse	r24, r1
    13f8:	03 c0       	rjmp	.+6      	; 0x1400 <vTaskIncrementTick+0x6e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    13fa:	8f ef       	ldi	r24, 0xFF	; 255
    13fc:	9f ef       	ldi	r25, 0xFF	; 255
    13fe:	0c c0       	rjmp	.+24     	; 0x1418 <vTaskIncrementTick+0x86>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1400:	e0 91 93 06 	lds	r30, 0x0693	; 0x800693 <pxDelayedTaskList>
    1404:	f0 91 94 06 	lds	r31, 0x0694	; 0x800694 <pxDelayedTaskList+0x1>
    1408:	05 80       	ldd	r0, Z+5	; 0x05
    140a:	f6 81       	ldd	r31, Z+6	; 0x06
    140c:	e0 2d       	mov	r30, r0
    140e:	06 80       	ldd	r0, Z+6	; 0x06
    1410:	f7 81       	ldd	r31, Z+7	; 0x07
    1412:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1414:	82 81       	ldd	r24, Z+2	; 0x02
    1416:	93 81       	ldd	r25, Z+3	; 0x03
    1418:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <xNextTaskUnblockTime+0x1>
    141c:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <xNextTaskUnblockTime>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1420:	20 91 85 06 	lds	r18, 0x0685	; 0x800685 <xTickCount>
    1424:	30 91 86 06 	lds	r19, 0x0686	; 0x800686 <xTickCount+0x1>
    1428:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <xNextTaskUnblockTime>
    142c:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <xNextTaskUnblockTime+0x1>
    1430:	28 17       	cp	r18, r24
    1432:	39 07       	cpc	r19, r25
    1434:	08 f4       	brcc	.+2      	; 0x1438 <vTaskIncrementTick+0xa6>
    1436:	43 c0       	rjmp	.+134    	; 0x14be <vTaskIncrementTick+0x12c>
    1438:	89 e0       	ldi	r24, 0x09	; 9
    143a:	f8 2e       	mov	r15, r24
    143c:	e0 91 93 06 	lds	r30, 0x0693	; 0x800693 <pxDelayedTaskList>
    1440:	f0 91 94 06 	lds	r31, 0x0694	; 0x800694 <pxDelayedTaskList+0x1>
    1444:	80 81       	ld	r24, Z
    1446:	81 11       	cpse	r24, r1
    1448:	03 c0       	rjmp	.+6      	; 0x1450 <vTaskIncrementTick+0xbe>
    144a:	8f ef       	ldi	r24, 0xFF	; 255
    144c:	9f ef       	ldi	r25, 0xFF	; 255
    144e:	12 c0       	rjmp	.+36     	; 0x1474 <vTaskIncrementTick+0xe2>
    1450:	e0 91 93 06 	lds	r30, 0x0693	; 0x800693 <pxDelayedTaskList>
    1454:	f0 91 94 06 	lds	r31, 0x0694	; 0x800694 <pxDelayedTaskList+0x1>
    1458:	05 80       	ldd	r0, Z+5	; 0x05
    145a:	f6 81       	ldd	r31, Z+6	; 0x06
    145c:	e0 2d       	mov	r30, r0
    145e:	c6 81       	ldd	r28, Z+6	; 0x06
    1460:	d7 81       	ldd	r29, Z+7	; 0x07
    1462:	8a 81       	ldd	r24, Y+2	; 0x02
    1464:	9b 81       	ldd	r25, Y+3	; 0x03
    1466:	20 91 85 06 	lds	r18, 0x0685	; 0x800685 <xTickCount>
    146a:	30 91 86 06 	lds	r19, 0x0686	; 0x800686 <xTickCount+0x1>
    146e:	28 17       	cp	r18, r24
    1470:	39 07       	cpc	r19, r25
    1472:	28 f4       	brcc	.+10     	; 0x147e <vTaskIncrementTick+0xec>
    1474:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <xNextTaskUnblockTime+0x1>
    1478:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <xNextTaskUnblockTime>
    147c:	20 c0       	rjmp	.+64     	; 0x14be <vTaskIncrementTick+0x12c>
    147e:	8e 01       	movw	r16, r28
    1480:	0e 5f       	subi	r16, 0xFE	; 254
    1482:	1f 4f       	sbci	r17, 0xFF	; 255
    1484:	c8 01       	movw	r24, r16
    1486:	0c da       	rcall	.-3048   	; 0x8a0 <vListRemove>
    1488:	8c 89       	ldd	r24, Y+20	; 0x14
    148a:	9d 89       	ldd	r25, Y+21	; 0x15
    148c:	89 2b       	or	r24, r25
    148e:	19 f0       	breq	.+6      	; 0x1496 <vTaskIncrementTick+0x104>
    1490:	ce 01       	movw	r24, r28
    1492:	0c 96       	adiw	r24, 0x0c	; 12
    1494:	05 da       	rcall	.-3062   	; 0x8a0 <vListRemove>
    1496:	8e 89       	ldd	r24, Y+22	; 0x16
    1498:	90 91 83 06 	lds	r25, 0x0683	; 0x800683 <uxTopReadyPriority>
    149c:	98 17       	cp	r25, r24
    149e:	10 f4       	brcc	.+4      	; 0x14a4 <vTaskIncrementTick+0x112>
    14a0:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <uxTopReadyPriority>
    14a4:	f8 9e       	mul	r15, r24
    14a6:	c0 01       	movw	r24, r0
    14a8:	11 24       	eor	r1, r1
    14aa:	b8 01       	movw	r22, r16
    14ac:	89 55       	subi	r24, 0x59	; 89
    14ae:	99 4f       	sbci	r25, 0xF9	; 249
    14b0:	9d d9       	rcall	.-3270   	; 0x7ec <vListInsertEnd>
    14b2:	c4 cf       	rjmp	.-120    	; 0x143c <vTaskIncrementTick+0xaa>
	}
	else
	{
		++uxMissedTicks;
    14b4:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <uxMissedTicks>
    14b8:	8f 5f       	subi	r24, 0xFF	; 255
    14ba:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    14be:	df 91       	pop	r29
    14c0:	cf 91       	pop	r28
    14c2:	1f 91       	pop	r17
    14c4:	0f 91       	pop	r16
    14c6:	ff 90       	pop	r15
    14c8:	08 95       	ret

000014ca <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    14ca:	ef 92       	push	r14
    14cc:	ff 92       	push	r15
    14ce:	0f 93       	push	r16
    14d0:	1f 93       	push	r17
    14d2:	cf 93       	push	r28
    14d4:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    14d6:	0f b6       	in	r0, 0x3f	; 63
    14d8:	f8 94       	cli
    14da:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    14dc:	80 91 81 06 	lds	r24, 0x0681	; 0x800681 <uxSchedulerSuspended>
    14e0:	81 50       	subi	r24, 0x01	; 1
    14e2:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    14e6:	80 91 81 06 	lds	r24, 0x0681	; 0x800681 <uxSchedulerSuspended>
    14ea:	88 23       	and	r24, r24
    14ec:	11 f0       	breq	.+4      	; 0x14f2 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    14ee:	80 e0       	ldi	r24, 0x00	; 0
    14f0:	4c c0       	rjmp	.+152    	; 0x158a <xTaskResumeAll+0xc0>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    14f2:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <uxCurrentNumberOfTasks>
    14f6:	88 23       	and	r24, r24
    14f8:	d1 f3       	breq	.-12     	; 0x14ee <xTaskResumeAll+0x24>
    14fa:	10 e0       	ldi	r17, 0x00	; 0
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    14fc:	09 e0       	ldi	r16, 0x09	; 9
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    14fe:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <xPendingReadyList>
    1502:	88 23       	and	r24, r24
    1504:	39 f1       	breq	.+78     	; 0x1554 <xTaskResumeAll+0x8a>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1506:	e0 91 8d 06 	lds	r30, 0x068D	; 0x80068d <xPendingReadyList+0x5>
    150a:	f0 91 8e 06 	lds	r31, 0x068E	; 0x80068e <xPendingReadyList+0x6>
    150e:	c6 81       	ldd	r28, Z+6	; 0x06
    1510:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    1512:	ce 01       	movw	r24, r28
    1514:	0c 96       	adiw	r24, 0x0c	; 12
    1516:	c4 d9       	rcall	.-3192   	; 0x8a0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1518:	7e 01       	movw	r14, r28
    151a:	82 e0       	ldi	r24, 0x02	; 2
    151c:	e8 0e       	add	r14, r24
    151e:	f1 1c       	adc	r15, r1
    1520:	c7 01       	movw	r24, r14
    1522:	be d9       	rcall	.-3204   	; 0x8a0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1524:	8e 89       	ldd	r24, Y+22	; 0x16
    1526:	90 91 83 06 	lds	r25, 0x0683	; 0x800683 <uxTopReadyPriority>
    152a:	98 17       	cp	r25, r24
    152c:	10 f4       	brcc	.+4      	; 0x1532 <xTaskResumeAll+0x68>
    152e:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <uxTopReadyPriority>
    1532:	08 9f       	mul	r16, r24
    1534:	c0 01       	movw	r24, r0
    1536:	11 24       	eor	r1, r1
    1538:	b7 01       	movw	r22, r14
    153a:	89 55       	subi	r24, 0x59	; 89
    153c:	99 4f       	sbci	r25, 0xF9	; 249
    153e:	56 d9       	rcall	.-3412   	; 0x7ec <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1540:	e0 91 cb 06 	lds	r30, 0x06CB	; 0x8006cb <pxCurrentTCB>
    1544:	f0 91 cc 06 	lds	r31, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
    1548:	9e 89       	ldd	r25, Y+22	; 0x16
    154a:	86 89       	ldd	r24, Z+22	; 0x16
    154c:	98 17       	cp	r25, r24
    154e:	b8 f2       	brcs	.-82     	; 0x14fe <xTaskResumeAll+0x34>
					{
						xYieldRequired = pdTRUE;
    1550:	11 e0       	ldi	r17, 0x01	; 1
    1552:	d5 cf       	rjmp	.-86     	; 0x14fe <xTaskResumeAll+0x34>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1554:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <uxMissedTicks>
    1558:	81 11       	cpse	r24, r1
    155a:	03 c0       	rjmp	.+6      	; 0x1562 <xTaskResumeAll+0x98>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    155c:	11 30       	cpi	r17, 0x01	; 1
    155e:	61 f4       	brne	.+24     	; 0x1578 <xTaskResumeAll+0xae>
    1560:	10 c0       	rjmp	.+32     	; 0x1582 <xTaskResumeAll+0xb8>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1562:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <uxMissedTicks>
    1566:	88 23       	and	r24, r24
					{
						vTaskIncrementTick();
    1568:	c9 f3       	breq	.-14     	; 0x155c <xTaskResumeAll+0x92>
    156a:	13 df       	rcall	.-474    	; 0x1392 <vTaskIncrementTick>
						--uxMissedTicks;
    156c:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <uxMissedTicks>
    1570:	81 50       	subi	r24, 0x01	; 1
    1572:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <uxMissedTicks>
    1576:	f5 cf       	rjmp	.-22     	; 0x1562 <xTaskResumeAll+0x98>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1578:	80 91 7f 06 	lds	r24, 0x067F	; 0x80067f <xMissedYield>
    157c:	81 30       	cpi	r24, 0x01	; 1
    157e:	09 f0       	breq	.+2      	; 0x1582 <xTaskResumeAll+0xb8>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1580:	b6 cf       	rjmp	.-148    	; 0x14ee <xTaskResumeAll+0x24>
    1582:	10 92 7f 06 	sts	0x067F, r1	; 0x80067f <xMissedYield>
					portYIELD_WITHIN_API();
    1586:	21 db       	rcall	.-2494   	; 0xbca <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1588:	81 e0       	ldi	r24, 0x01	; 1
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    158a:	0f 90       	pop	r0
    158c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    158e:	df 91       	pop	r29
    1590:	cf 91       	pop	r28
    1592:	1f 91       	pop	r17
    1594:	0f 91       	pop	r16
    1596:	ff 90       	pop	r15
    1598:	ef 90       	pop	r14
    159a:	08 95       	ret

0000159c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    159c:	cf 93       	push	r28
    159e:	df 93       	push	r29
    15a0:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    15a2:	89 2b       	or	r24, r25
    15a4:	11 f4       	brne	.+4      	; 0x15aa <vTaskDelay+0xe>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    15a6:	11 db       	rcall	.-2526   	; 0xbca <vPortYield>
    15a8:	12 c0       	rjmp	.+36     	; 0x15ce <vTaskDelay+0x32>
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
		{
			vTaskSuspendAll();
    15aa:	ed de       	rcall	.-550    	; 0x1386 <vTaskSuspendAll>
    15ac:	80 91 85 06 	lds	r24, 0x0685	; 0x800685 <xTickCount>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    15b0:	90 91 86 06 	lds	r25, 0x0686	; 0x800686 <xTickCount+0x1>
    15b4:	c8 0f       	add	r28, r24
    15b6:	d9 1f       	adc	r29, r25
    15b8:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <pxCurrentTCB>

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    15bc:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
    15c0:	02 96       	adiw	r24, 0x02	; 2
    15c2:	6e d9       	rcall	.-3364   	; 0x8a0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    15c4:	ce 01       	movw	r24, r28
    15c6:	97 dd       	rcall	.-1234   	; 0x10f6 <prvAddCurrentTaskToDelayedList>
    15c8:	80 df       	rcall	.-256    	; 0x14ca <xTaskResumeAll>
			}
			xAlreadyYielded = xTaskResumeAll();
    15ca:	88 23       	and	r24, r24
    15cc:	61 f3       	breq	.-40     	; 0x15a6 <vTaskDelay+0xa>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    15ce:	df 91       	pop	r29
    15d0:	cf 91       	pop	r28
		{
			portYIELD_WITHIN_API();
		}
	}
    15d2:	08 95       	ret

000015d4 <vTaskSwitchContext>:
    15d4:	80 91 81 06 	lds	r24, 0x0681	; 0x800681 <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    15d8:	88 23       	and	r24, r24
    15da:	21 f0       	breq	.+8      	; 0x15e4 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    15dc:	81 e0       	ldi	r24, 0x01	; 1
    15de:	80 93 7f 06 	sts	0x067F, r24	; 0x80067f <xMissedYield>
    15e2:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    15e4:	99 e0       	ldi	r25, 0x09	; 9
    15e6:	e0 91 83 06 	lds	r30, 0x0683	; 0x800683 <uxTopReadyPriority>
    15ea:	9e 9f       	mul	r25, r30
    15ec:	f0 01       	movw	r30, r0
    15ee:	11 24       	eor	r1, r1
    15f0:	e9 55       	subi	r30, 0x59	; 89
    15f2:	f9 4f       	sbci	r31, 0xF9	; 249
    15f4:	80 81       	ld	r24, Z
    15f6:	81 11       	cpse	r24, r1
    15f8:	06 c0       	rjmp	.+12     	; 0x1606 <vTaskSwitchContext+0x32>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    15fa:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <uxTopReadyPriority>
    15fe:	81 50       	subi	r24, 0x01	; 1
    1600:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <uxTopReadyPriority>
    1604:	f0 cf       	rjmp	.-32     	; 0x15e6 <vTaskSwitchContext+0x12>
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1606:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <uxTopReadyPriority>
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	49 e0       	ldi	r20, 0x09	; 9
    160e:	48 9f       	mul	r20, r24
    1610:	90 01       	movw	r18, r0
    1612:	49 9f       	mul	r20, r25
    1614:	30 0d       	add	r19, r0
    1616:	11 24       	eor	r1, r1
    1618:	f9 01       	movw	r30, r18
    161a:	e9 55       	subi	r30, 0x59	; 89
    161c:	f9 4f       	sbci	r31, 0xF9	; 249
    161e:	a1 81       	ldd	r26, Z+1	; 0x01
    1620:	b2 81       	ldd	r27, Z+2	; 0x02
    1622:	12 96       	adiw	r26, 0x02	; 2
    1624:	0d 90       	ld	r0, X+
    1626:	bc 91       	ld	r27, X
    1628:	a0 2d       	mov	r26, r0
    162a:	b2 83       	std	Z+2, r27	; 0x02
    162c:	a1 83       	std	Z+1, r26	; 0x01
    162e:	26 55       	subi	r18, 0x56	; 86
    1630:	39 4f       	sbci	r19, 0xF9	; 249
    1632:	a2 17       	cp	r26, r18
    1634:	b3 07       	cpc	r27, r19
    1636:	31 f4       	brne	.+12     	; 0x1644 <vTaskSwitchContext+0x70>
    1638:	12 96       	adiw	r26, 0x02	; 2
    163a:	2d 91       	ld	r18, X+
    163c:	3c 91       	ld	r19, X
    163e:	13 97       	sbiw	r26, 0x03	; 3
    1640:	32 83       	std	Z+2, r19	; 0x02
    1642:	21 83       	std	Z+1, r18	; 0x01
    1644:	29 e0       	ldi	r18, 0x09	; 9
    1646:	28 9f       	mul	r18, r24
    1648:	f0 01       	movw	r30, r0
    164a:	29 9f       	mul	r18, r25
    164c:	f0 0d       	add	r31, r0
    164e:	11 24       	eor	r1, r1
    1650:	e9 55       	subi	r30, 0x59	; 89
    1652:	f9 4f       	sbci	r31, 0xF9	; 249
    1654:	01 80       	ldd	r0, Z+1	; 0x01
    1656:	f2 81       	ldd	r31, Z+2	; 0x02
    1658:	e0 2d       	mov	r30, r0
    165a:	86 81       	ldd	r24, Z+6	; 0x06
    165c:	97 81       	ldd	r25, Z+7	; 0x07
    165e:	90 93 cc 06 	sts	0x06CC, r25	; 0x8006cc <pxCurrentTCB+0x1>
    1662:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <pxCurrentTCB>
    1666:	08 95       	ret

00001668 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1668:	cf 93       	push	r28
    166a:	df 93       	push	r29
    166c:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    166e:	60 91 cb 06 	lds	r22, 0x06CB	; 0x8006cb <pxCurrentTCB>
    1672:	70 91 cc 06 	lds	r23, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
    1676:	64 5f       	subi	r22, 0xF4	; 244
    1678:	7f 4f       	sbci	r23, 0xFF	; 255
    167a:	db d8       	rcall	.-3658   	; 0x832 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    167c:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <pxCurrentTCB>
    1680:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
    1684:	02 96       	adiw	r24, 0x02	; 2
    1686:	0c d9       	rcall	.-3560   	; 0x8a0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1688:	80 91 85 06 	lds	r24, 0x0685	; 0x800685 <xTickCount>
    168c:	90 91 86 06 	lds	r25, 0x0686	; 0x800686 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1690:	8c 0f       	add	r24, r28
    1692:	9d 1f       	adc	r25, r29
	}
	#endif
}
    1694:	df 91       	pop	r29
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1696:	cf 91       	pop	r28
    1698:	2e cd       	rjmp	.-1444   	; 0x10f6 <prvAddCurrentTaskToDelayedList>

0000169a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    169a:	0f 93       	push	r16
    169c:	1f 93       	push	r17
    169e:	cf 93       	push	r28
    16a0:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    16a2:	dc 01       	movw	r26, r24
    16a4:	15 96       	adiw	r26, 0x05	; 5
    16a6:	ed 91       	ld	r30, X+
    16a8:	fc 91       	ld	r31, X
    16aa:	16 97       	sbiw	r26, 0x06	; 6
    16ac:	c6 81       	ldd	r28, Z+6	; 0x06
    16ae:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    16b0:	8e 01       	movw	r16, r28
    16b2:	04 5f       	subi	r16, 0xF4	; 244
    16b4:	1f 4f       	sbci	r17, 0xFF	; 255
    16b6:	c8 01       	movw	r24, r16
    16b8:	f3 d8       	rcall	.-3610   	; 0x8a0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    16ba:	80 91 81 06 	lds	r24, 0x0681	; 0x800681 <uxSchedulerSuspended>
    16be:	81 11       	cpse	r24, r1
    16c0:	13 c0       	rjmp	.+38     	; 0x16e8 <xTaskRemoveFromEventList+0x4e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    16c2:	0a 50       	subi	r16, 0x0A	; 10
    16c4:	11 09       	sbc	r17, r1
    16c6:	c8 01       	movw	r24, r16
    16c8:	eb d8       	rcall	.-3626   	; 0x8a0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    16ca:	8e 89       	ldd	r24, Y+22	; 0x16
    16cc:	90 91 83 06 	lds	r25, 0x0683	; 0x800683 <uxTopReadyPriority>
    16d0:	98 17       	cp	r25, r24
    16d2:	10 f4       	brcc	.+4      	; 0x16d8 <xTaskRemoveFromEventList+0x3e>
    16d4:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <uxTopReadyPriority>
    16d8:	b9 e0       	ldi	r27, 0x09	; 9
    16da:	8b 9f       	mul	r24, r27
    16dc:	c0 01       	movw	r24, r0
    16de:	11 24       	eor	r1, r1
    16e0:	b8 01       	movw	r22, r16
    16e2:	89 55       	subi	r24, 0x59	; 89
    16e4:	99 4f       	sbci	r25, 0xF9	; 249
    16e6:	03 c0       	rjmp	.+6      	; 0x16ee <xTaskRemoveFromEventList+0x54>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    16e8:	b8 01       	movw	r22, r16
    16ea:	88 e8       	ldi	r24, 0x88	; 136
    16ec:	96 e0       	ldi	r25, 0x06	; 6
    16ee:	7e d8       	rcall	.-3844   	; 0x7ec <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    16f0:	e0 91 cb 06 	lds	r30, 0x06CB	; 0x8006cb <pxCurrentTCB>
    16f4:	f0 91 cc 06 	lds	r31, 0x06CC	; 0x8006cc <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    16f8:	81 e0       	ldi	r24, 0x01	; 1
    16fa:	2e 89       	ldd	r18, Y+22	; 0x16
    16fc:	96 89       	ldd	r25, Z+22	; 0x16
    16fe:	29 17       	cp	r18, r25
    1700:	08 f4       	brcc	.+2      	; 0x1704 <xTaskRemoveFromEventList+0x6a>
    1702:	80 e0       	ldi	r24, 0x00	; 0
}
    1704:	df 91       	pop	r29
    1706:	cf 91       	pop	r28
    1708:	1f 91       	pop	r17
    170a:	0f 91       	pop	r16
    170c:	08 95       	ret

0000170e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    170e:	20 91 7e 06 	lds	r18, 0x067E	; 0x80067e <xNumOfOverflows>
    1712:	fc 01       	movw	r30, r24
    1714:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1716:	20 91 85 06 	lds	r18, 0x0685	; 0x800685 <xTickCount>
    171a:	30 91 86 06 	lds	r19, 0x0686	; 0x800686 <xTickCount+0x1>
    171e:	32 83       	std	Z+2, r19	; 0x02
    1720:	21 83       	std	Z+1, r18	; 0x01
    1722:	08 95       	ret

00001724 <xTaskCheckForTimeOut>:
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1724:	0f b6       	in	r0, 0x3f	; 63
    1726:	f8 94       	cli
    1728:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    172a:	20 91 7e 06 	lds	r18, 0x067E	; 0x80067e <xNumOfOverflows>
    172e:	dc 01       	movw	r26, r24
    1730:	3c 91       	ld	r19, X
    1732:	11 96       	adiw	r26, 0x01	; 1
    1734:	ed 91       	ld	r30, X+
    1736:	fc 91       	ld	r31, X
    1738:	12 97       	sbiw	r26, 0x02	; 2
    173a:	32 17       	cp	r19, r18
    173c:	39 f0       	breq	.+14     	; 0x174c <xTaskCheckForTimeOut+0x28>
    173e:	20 91 85 06 	lds	r18, 0x0685	; 0x800685 <xTickCount>
    1742:	30 91 86 06 	lds	r19, 0x0686	; 0x800686 <xTickCount+0x1>
    1746:	2e 17       	cp	r18, r30
    1748:	3f 07       	cpc	r19, r31
    174a:	d0 f4       	brcc	.+52     	; 0x1780 <xTaskCheckForTimeOut+0x5c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    174c:	40 91 85 06 	lds	r20, 0x0685	; 0x800685 <xTickCount>
    1750:	50 91 86 06 	lds	r21, 0x0686	; 0x800686 <xTickCount+0x1>
    1754:	db 01       	movw	r26, r22
    1756:	2d 91       	ld	r18, X+
    1758:	3c 91       	ld	r19, X
    175a:	11 97       	sbiw	r26, 0x01	; 1
    175c:	4e 1b       	sub	r20, r30
    175e:	5f 0b       	sbc	r21, r31
    1760:	42 17       	cp	r20, r18
    1762:	53 07       	cpc	r21, r19
    1764:	68 f4       	brcc	.+26     	; 0x1780 <xTaskCheckForTimeOut+0x5c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1766:	40 91 85 06 	lds	r20, 0x0685	; 0x800685 <xTickCount>
    176a:	50 91 86 06 	lds	r21, 0x0686	; 0x800686 <xTickCount+0x1>
    176e:	4e 1b       	sub	r20, r30
    1770:	5f 0b       	sbc	r21, r31
    1772:	24 1b       	sub	r18, r20
    1774:	35 0b       	sbc	r19, r21
    1776:	2d 93       	st	X+, r18
    1778:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    177a:	c9 df       	rcall	.-110    	; 0x170e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    177c:	80 e0       	ldi	r24, 0x00	; 0
    177e:	01 c0       	rjmp	.+2      	; 0x1782 <xTaskCheckForTimeOut+0x5e>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1780:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1782:	0f 90       	pop	r0
    1784:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1786:	08 95       	ret

00001788 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	80 93 7f 06 	sts	0x067F, r24	; 0x80067f <xMissedYield>
    178e:	08 95       	ret

00001790 <__divmodhi4>:
    1790:	97 fb       	bst	r25, 7
    1792:	07 2e       	mov	r0, r23
    1794:	16 f4       	brtc	.+4      	; 0x179a <__divmodhi4+0xa>
    1796:	00 94       	com	r0
    1798:	06 d0       	rcall	.+12     	; 0x17a6 <__divmodhi4_neg1>
    179a:	77 fd       	sbrc	r23, 7
    179c:	08 d0       	rcall	.+16     	; 0x17ae <__divmodhi4_neg2>
    179e:	0b d0       	rcall	.+22     	; 0x17b6 <__udivmodhi4>
    17a0:	07 fc       	sbrc	r0, 7
    17a2:	05 d0       	rcall	.+10     	; 0x17ae <__divmodhi4_neg2>
    17a4:	3e f4       	brtc	.+14     	; 0x17b4 <__divmodhi4_exit>

000017a6 <__divmodhi4_neg1>:
    17a6:	90 95       	com	r25
    17a8:	81 95       	neg	r24
    17aa:	9f 4f       	sbci	r25, 0xFF	; 255
    17ac:	08 95       	ret

000017ae <__divmodhi4_neg2>:
    17ae:	70 95       	com	r23
    17b0:	61 95       	neg	r22
    17b2:	7f 4f       	sbci	r23, 0xFF	; 255

000017b4 <__divmodhi4_exit>:
    17b4:	08 95       	ret

000017b6 <__udivmodhi4>:
    17b6:	aa 1b       	sub	r26, r26
    17b8:	bb 1b       	sub	r27, r27
    17ba:	51 e1       	ldi	r21, 0x11	; 17
    17bc:	07 c0       	rjmp	.+14     	; 0x17cc <__udivmodhi4_ep>

000017be <__udivmodhi4_loop>:
    17be:	aa 1f       	adc	r26, r26
    17c0:	bb 1f       	adc	r27, r27
    17c2:	a6 17       	cp	r26, r22
    17c4:	b7 07       	cpc	r27, r23
    17c6:	10 f0       	brcs	.+4      	; 0x17cc <__udivmodhi4_ep>
    17c8:	a6 1b       	sub	r26, r22
    17ca:	b7 0b       	sbc	r27, r23

000017cc <__udivmodhi4_ep>:
    17cc:	88 1f       	adc	r24, r24
    17ce:	99 1f       	adc	r25, r25
    17d0:	5a 95       	dec	r21
    17d2:	a9 f7       	brne	.-22     	; 0x17be <__udivmodhi4_loop>
    17d4:	80 95       	com	r24
    17d6:	90 95       	com	r25
    17d8:	bc 01       	movw	r22, r24
    17da:	cd 01       	movw	r24, r26
    17dc:	08 95       	ret

000017de <memcpy>:
    17de:	fb 01       	movw	r30, r22
    17e0:	dc 01       	movw	r26, r24
    17e2:	02 c0       	rjmp	.+4      	; 0x17e8 <memcpy+0xa>
    17e4:	01 90       	ld	r0, Z+
    17e6:	0d 92       	st	X+, r0
    17e8:	41 50       	subi	r20, 0x01	; 1
    17ea:	50 40       	sbci	r21, 0x00	; 0
    17ec:	d8 f7       	brcc	.-10     	; 0x17e4 <memcpy+0x6>
    17ee:	08 95       	ret

000017f0 <memset>:
    17f0:	dc 01       	movw	r26, r24
    17f2:	01 c0       	rjmp	.+2      	; 0x17f6 <memset+0x6>
    17f4:	6d 93       	st	X+, r22
    17f6:	41 50       	subi	r20, 0x01	; 1
    17f8:	50 40       	sbci	r21, 0x00	; 0
    17fa:	e0 f7       	brcc	.-8      	; 0x17f4 <memset+0x4>
    17fc:	08 95       	ret

000017fe <strncpy>:
    17fe:	fb 01       	movw	r30, r22
    1800:	dc 01       	movw	r26, r24
    1802:	41 50       	subi	r20, 0x01	; 1
    1804:	50 40       	sbci	r21, 0x00	; 0
    1806:	48 f0       	brcs	.+18     	; 0x181a <strncpy+0x1c>
    1808:	01 90       	ld	r0, Z+
    180a:	0d 92       	st	X+, r0
    180c:	00 20       	and	r0, r0
    180e:	c9 f7       	brne	.-14     	; 0x1802 <strncpy+0x4>
    1810:	01 c0       	rjmp	.+2      	; 0x1814 <strncpy+0x16>
    1812:	1d 92       	st	X+, r1
    1814:	41 50       	subi	r20, 0x01	; 1
    1816:	50 40       	sbci	r21, 0x00	; 0
    1818:	e0 f7       	brcc	.-8      	; 0x1812 <strncpy+0x14>
    181a:	08 95       	ret

0000181c <_exit>:
    181c:	f8 94       	cli

0000181e <__stop_program>:
    181e:	ff cf       	rjmp	.-2      	; 0x181e <__stop_program>
